# 第 8 章 机器人平台设计

学习到当前阶段大家对ROS已经有一定的认知了，但是之前的内容更偏理论，尤其是介绍完第6章仿真与第7章导航之后，想必相当一部分同学有些疑惑：

> 实体机器人与仿真实现有什么区别？
>
> ROS系统如何控制机器人底盘运动，并计算里程计数据呢？
>
> 实际的传感器如雷达、摄像头等应该怎么使用呢？
>
> ...

机器人系统是一套机电一体化的设备，机器人设计也是高度集成的系统性实现，为了给大家解答上述疑惑，方便机器人硬件的快速上手，本章去繁就简旨在从0到1的设计一款入门级、低成本、简单但又具备一定扩展性的两轮差速机器人，学习完本章内容之后，你甚至可以构建属于自己的机器人平台。

本章主要介绍内容如下:

- 机器人的组成部分；
- Arduino 基本使用；
- Arduino 与电机驱动；
- 底盘控制实现；
- 基于树莓派的ROS环境搭建；
- 激光雷达与相机的基本使用与集成。

本章学习目标如下：

- 能够独立搭建机器人平台。

**注意:**

- 该章内容会使用到ROS的分布式框架，树莓派端作为主机，PC端作为从机；
- PC端使用的ROS版本为noetic，树莓派端使用的版本为melodic，因为树莓派需要与底盘交互，而相关功能包还未更新。

**案例演示:**

1.机器人底盘实现

底盘正面![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BA%95%E7%9B%98.jpg)

Arduino 与 电机驱动板![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/Arduino%E4%B8%8E%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF.jpg)

底盘背面![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E5%BA%95%E7%9B%98%E8%83%8C%E9%9D%A2.jpg)

2.机器人控制系统以及传感器实现![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%8A%E4%BD%8D%E6%9C%BA%E4%BB%A5%E5%8F%8A%E4%BC%A0%E6%84%9F%E5%99%A8.jpg)

3.机器人集成效果![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%A1%AC%E4%BB%B6%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95.PNG)

## 8.1 概述

立足角度不同，对机器人组成的认识也会有明显差异，从控制的角度来看，机器人系统可以分为四部分:

> 传感系统、控制系统、驱动系统、执行机构。

#### 1.传感系统

它由内部传感器模块和外部传感器模块组成，获取内部和外部环境中有用的信息，相当于人体的感官与神经，内部传感系统包括电机的编码器、陀螺仪等，可以通过自身信号反馈检测位姿状态；外部传感系统包括摄像头、红外、声纳等，用于感知外部环境。

#### 2.控制系统

控制系统的任务是根据机器人的作业指令以及从传感器反馈回来的信号，输出控制命令信号，类似于人的大脑。控制系统需要基于处理器实现，在处理器之上，控制系统需要完成算法处理、关节控制、人机交互等复杂功能。

#### 3.驱动系统

驱动系统主要负责驱动执行机构，将控制系统下达的命令转换成执行机构所需要的信号，相当于人的小脑与神经。采用的动力源不同，驱动系统的传动方式也不同。驱动系统的传动方式主要有四种：液压式、气压式、电气式和机械式。电力驱动是目前使用最多的一种驱动方式，其特点是电源取用方便，响应快，驱动力大，信号检测、传递、处理方便，并可以采用多种灵活的控制方式，驱动电机一般采用步进电机或伺服电机。

#### 4.执行机构

执行机构是机器人组成中的机械部分，类似于人的手与脚，比如:机器人的行走部分与机械臂。

------

在当前机器人系统中，各组成部分对应硬件清单如下:

**执行机构:** 主体使用亚克力板拼装，由两个直流电机带动主动轮以及保持平衡的两个万向轮实现机器人行走，由于执行机构比较简单，不再做单独介绍。

**驱动系统:** 电池、arduino 以及电机驱动模块；

**控制系统:** 树莓派；

**传感系统:** 编码器、单线激光雷达、相机；

其中，执行机构与驱动系统构成了机器人底盘。

## 8.2 机器人平台设计之arduino基础

在构建差分轮式机器人平台时，驱动系统的常用实现有 STM32 或 Arduino，在此，我们选用后者，因为 Arduino 相较而言更简单、易于上手。本节将介绍如下内容:

- arduino 简介；
- arduino 开发环境搭建；
- arduino 基本语法。

------

#### 概念

Arduino是一款便捷灵活、方便上手的开源电子原型平台。在它上面可以进行简单的电路控制设计，Arduino能够通过各种各样的传感器来感知环境，通过控制灯光、马达和其他的装置来反馈、影响环境。

#### 作用

或多或少你可能听说过“集成电路”(又称“微电路”、“微芯片”或“芯片”)这种概念，集成电路（integrated circuit）是一种微型电子器件或部件，通过集成电路再结合一些外围的电子电子元器件、传感器等，可以感知环境(温度、湿度、声音)，也可以影响环境(控制灯的开关、调节电机转速)。但是传统的集成电路应用比较繁琐，一般需要具有一定电子知识基础，并懂得如何进行相关的程序设计的工程师才能熟练使用，而Arduino的出现才使得以往高度专业的集成电路变得平易近人，Arduino主要优点如下:

- **简单:**在硬件方面，Arduino本身是一款非常容易使用的印刷电路板。电路板上装有专用集成电路，并将集成电路的功能引脚引出方便我们外接使用。同时，电路板还设计有USB接口方便与电脑连接；
- **易学:**只需要掌握 C/C++ 基本语法即可；
- **易用:**Arduino提供了专门的程序开发环境Arduino IDE，可以提高程序实现效率。

当前，Arduino已经成为全世界电子爱好者电子制作过程中的重要选项之一。

#### 组成

Arduino 体系主要包含硬件和软件两大部分。硬件部分是可以用来做电路连接的各种型号的Arduino电路板(下图为本章内容使用的 arduino mega 2560)；软件部分则是Arduino IDE。你只要在IDE中编写程序代码，将程序上传到Arduino电路板后，程序便会告诉Arduino电路板要做些什么了。

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/ArduinoMega2560.jfif)

### 8.2.1 arduino 开发环境搭建

基于Arduino的开发实现，毋庸置疑的必须先要准备Arduino电路板(建议型号:Arduino Mega 2560)，除了硬件之外，还需要准备软件环境，安装 Arduino IDE，在 Ubuntu 下，Arduino 开发环境的搭建步骤如下:

1. 硬件准备: Arduino电路板连接 ubuntu
2. 软件准备: 安装 Arduino IDE
3. 编写 Arduino 程序并上传至 Arduino电路板。

#### 1.Arduino 连接 Ubuntu

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9E%E6%8E%A5arduino.png)

你需要确保你对这个接口有访问的权限。假设你的Arduino连接的是`/dev/ttyACM0`，那么就运行下面这个命令：

```
$ ls -l /dev/ttyACM0
```

然后你就可以看到类似于下面的输出结果：

> crw-rw—- 1 root dialout 166, 0 2013-02-24 08:31 /dev/ttyACM0

我们注意到在上面的结果中，只有root和”dialout”组才有读写权限。因此，你需要成为`dialout`组的一个成员。

命令如下:

```
$ sudo usermod -a -G dialout your_user_name
```

在这个命令中`your_user_name`就是你在Linux下登录的用户名。然后需要**重启**使之生效。执行完上面的操作之后，你可以运行下面的命令查看一下：

```
$ groups
```

然后如果你可以在列出的组中找到dialout，这就说明你已经加入到dialout中了。

#### 2.安装 Arduino IDE

##### 1.下载arduino ide安装包

官方下载链接：https://www.arduino.cc/en/Main/Software![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/arduino%E4%B8%8B%E8%BD%BD.PNG)选择对应版本即可![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/arduino%E4%B8%8B%E8%BD%BD2.PNG)可以选择捐款，或者 JUST DOWNLOAD。

##### 2.使用tar命令对压缩包解压

```
tar -xvf arduino-1.x.y-linux64.tar.xz
```

##### 3.将解压后的文件移动到/opt下

```
sudo mv arduino-1.x.y /opt
```

##### 4.进入安装目录,对install.sh添加可执行权限,并执行安装

```
cd /opt/arduino-1.x.y
sudo chmod +x install.sh
sudo ./install.sh
```

##### 5.启动并配置 Arduino IDE

在命令行直接输入:arduino,或者点击左下的显示应用程序搜索 arduino IDE。启动如下:![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/arduino%E5%90%AF%E5%8A%A8.PNG)Arduino IDE 配置如下:![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/ArduinoIDE%E9%85%8D%E7%BD%AE.png)

#### 3.Hello World实现

Arduino IDE 中已经内置了一些相关案例，在此，我们通过一个经典的控制 LED 等闪烁案例来演示 Arduino 的使用流程:

##### 1.案例调用![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/arduino_HelloWorld.PNG)

##### 

##### 2.编译及上传

先点击左上的编译按钮，可用于语法检测，编译无异常，再点击右侧的上传按钮，上传至 Arduino 电路板![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/arduino_HelloWorld2.PNG)

##### 3.运行结果

电路板上的 LED 灯闪烁

##### 4.代码解释

```cpp
// 初始化函数
void setup() {
  //将LED灯引脚(引脚值为13，被封装为了LED_BUTLIN)设置为输出模式
  pinMode(LED_BUILTIN, OUTPUT);
}

// 循环执行函数
void loop() {
  digitalWrite(LED_BUILTIN, HIGH);   // 打开LED灯
  delay(1000);                       // 休眠1000毫秒
  digitalWrite(LED_BUILTIN, LOW);    // 关闭LED灯
  delay(1000);                       // 休眠1000毫秒
}
```

setup 与 loop 函数是固定格式。

### 8.2.2 arduino 基本语法概述

Arduino 的语言系统在设计时参考了C、C++、Java，是一种综合性的简洁语言，语法更类似于C++，但是不支持C++的异常处理，没有STL库，你可以把它当作是精简后的C++。

Arduino 基本语法中，注释、宏定义、库文件包含、变量、函数、流程控制、类、继承、多态..... 都与 C++ 高度类似，在此不再赘述，着重要介绍的是，Arduino中的一些API实现。

#### 1.程序结构

一个 Arduino 程序分为两大部分: setup() 与 loop() 函数。

- **void setup():**在这个函数里初始化Arduino的程序，使主循环程序在开始之前设置好相关参数,初始化变量、设置针脚的输出\输入类型、设置波特率...。该函数只会在上电或重启时执行一次。
- **void loop():**这是Arduino的主函数。这套程序会一直重复执行，直到电源被断开。

#### 2.常量

在 Arduino 中封装了一些常用常量,比如:

- **HIGH | LOW**（引脚电压定义）
- **INPUT|OUTPUT**（数字引脚（Digital pins）定义）
- **true | false**（逻辑层定义）

#### 3.通信_Serial

Serial用于Arduino控制板和一台计算机或其他设备之间的通信。您可以使用Arduino IDE内置的串口监视器与Arduino板通信。点击工具栏上的串口监视器按钮，调用begin()函数（选择相同的波特率）。

- **Serial.begin() 初始化串口波特率**

  **描述:**将串行数据传输速率设置为位/秒（波特）。与计算机进行通信时，可以使用这些波特率：300，1200，2400，4800，9600，14400，19200，28800，38400，57600或115200。当然，您也可以指定其他波特率 - 例如，引脚0和1和一个元件进行通信，它需要一个特定的波特率。

  **语法:**Serial.begin(speed)

  **参数:**speed: 位/秒 (波特) - long

  **返回:**无

- **Serial.print() 从串口打印输出数据**

  **需求:**

  以人们可读的ASCII文本形式打印数据到串口输出。此命令可以采取多种形式。每个数字的打印输出使用的是ASCII字符。浮点型同样打印输出的是ASCII字符，保留到小数点后两位。Bytes型则打印输出单个字符。字符和字符串原样打印输出。Serial.print()打印输出数据不换行，Serial.println()打印输出数据自动换行处理。

  **语法:**Serial.print(val)

  **参数**

  val：打印输出的值 - 任何数据类型

  **返回:**字节 print()将返回写入的字节数，但是否使用（或读出）这个数字是可设定的

- **Serial.println()** 打印输出数据自动换行处理。参考 Serial.print();

- **Serial.available()**

  **描述:**获取从串口读取有效的字节数（字符）。这是已经传输到，并存储在串行接收缓冲区（能够存储64个字节）的数据。 available()继承了 Stream类。

  **语法:**Serial.available()

  **参数:**无

  **返回:**可读取的字节数

- **Serial.read()**

  **描述:**读取传入的串口的数据。read() 继承自 Stream 类。

  **语法:**serial.read()

  **参数:**无

  **返回:**传入的串口数据的第一个字节（或-1，如果没有可用的数据）

#### 4.函数_数字IO

- **pinMode()**

  **描述:**将指定的引脚配置成输出或输入。

  **语法:**pinMode(pin, mode)

  **参数**

  pin:要设置模式的引脚

  mode:INPUT或OUTPUT

  **返回:**无

- **digitalWrite()**

  **描述:**给一个数字引脚写入HIGH或者LOW。

  **语法:**digitalWrite(pin, value)

  **参数**

  pin: 引脚编号（如1,5,10，A0，A3）

  value: HIGH or LOW

  **返回:**无

- **digitalRead()**

  **描述:**读取指定引脚的值，HIGH或LOW。

  **语法:**digitalRead（PIN）

  **参数**

  pin：你想读取的引脚号（int）

  **返回:**HIGH 或 LOW

  **注意:**如果引脚悬空，digitalRead()会返回HIGH或LOW（随机变化）

#### 5.函数_模拟IO

- **analogWrite() PWM**

  **描述:**从一个引脚输出模拟值（PWM）。可用于让LED以不同的亮度点亮或驱动电机以不同的速度旋转。analogWrite()输出结束后，该引脚将产生一个稳定的特殊占空比方波，直到下次调用analogWrite()（或在同一引脚调用digitalRead()或digitalWrite()）。PWM信号的频率大约是490赫兹。

  在大多数arduino板（ATmega168或ATmega328），只有引脚3，5，6，9，10和11可以实现该功能。在aduino Mega上，引脚2到13可以实现该功能。老的Arduino板（ATmega8）的只有引脚9、10、11可以使用analogWrite()。在使用analogWrite()前，你不需要调用pinMode()来设置引脚为输出引脚。

  **语法:**analogWrite（pin,value）

  **参数**

  pin：用于输入数值的引脚。

  value：占空比：0（完全关闭）到255（完全打开）之间。

  **返回:**无

#### 6.函数_时间

- **delay()**

  **描述:**使程序暂定设定的时间（单位毫秒）。（一秒等于1000毫秒）

  **语法:**delay(ms)

  **参数**

  ms：暂停的毫秒数（unsigned long）

  **返回:**无

- **millis()**

  **描述:**返回Arduino开发板从运行当前程序开始的毫秒数。这个数字将在约50天后溢出（归零）。

  **参数:**无

  **返回:**返回从运行当前程序开始的毫秒数（无符号长整数）。

#### 7.函数_中断

- **attachInterrupt()**

  **描述:**当发生外部中断时，调用一个指定函数。当中断发生时，该函数会取代正在执行的程序。大多数的Arduino板有两个外部中断：0（数字引脚2）和1（数字引脚3）。

  arduino Mege还有其它有四个外部中断：数字2（引脚21），3（引脚20），4（引脚19），5（引脚18）。

  **语法:**attachInterrupt(interrupt, function, mode)

  interrupt：中断引脚数

  function：中断发生时调用的函数，此函数必须不带参数和不返回任何值。该函数有时被称为中断服务程序。

  mode：定义何时发生中断以下四个contstants预定有效值：

  - LOW 当引脚为低电平时，触发中断
  - CHANGE 当引脚电平发生改变时，触发中断
  - RISING 当引脚由低电平变为高电平时，触发中断
  - FALLING 当引脚由高电平变为低电平时，触发中断.

  **返回:**无

  **注意事项:**当中断函数发生时，delay()和millis()的数值将不会继续变化。当中断发生时，串口收到的数据可能会丢失。你应该声明一个变量来在未发生中断时储存变量。

- **noInterrupts()（禁止中断）**

  **描述:**禁止中断（重新使能中断interrupts()）。中断允许在后台运行一些重要任务，默认使能中断。禁止中断时部分函数会无法工作，通信中接收到的信息也可能会丢失。

  中断会稍影响计时代码，在某些特定的代码中也会失效。

  **参数:**无

  **返回:**无

- **interrupts()（中断）**

  **描述:**重新启用中断（使用noInterrupts()命令后将被禁用）。中断允许一些重要任务在后台运行，默认状态是启用的。禁用中断后一些函数可能无法工作，并传入信息可能会被忽略。中断会稍微打乱代码的时间，但是在关键部分可以禁用中断。

  **参数:**无

  **返回:**无

Arduino 的API还有很多，但是受于篇幅限制，当前只是简单介绍了和本教程相关的一些API实现。

### 8.2.3 arduino 基本语法演示

通信操作

#### 1.通信实现01

需求: 通过串口，由 arduino 向计算机发送数据

实现:

```cpp
/*
 * 需求:通过串口，由 arduino 向计算机发送数据
 * 实现:
 *  1.setup中设置波特率
 *  2.setup 或 loop 中使用 Serial.print 或 Serial.println() 发送数据
 * 
 * 
 * 
 */
void setup() {
  Serial.begin(57600);
  Serial.println("setup");
}

void loop() {
  delay(3000);
  Serial.print("loop");
  Serial.print("  ");
  Serial.println("hello");
}
Copy
```

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/arduino%E9%80%9A%E4%BF%A11.PNG)

#### 2.通信实现02

需求: 通过串口，由计算机向Arduino发送数据

实现:

```cpp
/*
 * 需求:通过串口，由计算机向 arduino 发送数据
 * 实现:
 *  1.setup中设置波特率
 *  2.loop 中接收发送的数据，并打印
 * 
 * 
 * 
 */
char num;
void setup() {
  Serial.begin(57600);
}

void loop() {
  if(Serial.available() > 0){
    num = Serial.read();
    Serial.print("I accept:");
    Serial.println(num);  
  }
}
Copy
```

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/arduino%E9%80%9A%E4%BF%A12.PNG)

### 8.2.4 arduino 基本语法演示02

#### **1.**数字IO操作

需求:控制LED灯开关，在一个循环周期内前两秒使LED灯处于点亮状态，后两秒关闭LED灯

实现:

```cpp
/*
 * 控制LED灯开关，在一个循环周期内前两秒使LED灯处于点亮状态，后两秒关闭LED灯
 * 1.setup 中设置引脚为输出模式
 * 2.loop 中向引脚输出高电压，休眠 2000 毫秒后，再输出低电压，再休眠 2000 毫秒
 * 
 */
int led = 13;
void setup() {
  Serial.begin(57600);
  pinMode(led,OUTPUT);

}

void loop() {

  digitalWrite(led,HIGH);//输出高电压  
  delay(2000);

  digitalWrite(led,LOW);//输出低电压
  delay(2000); 

}
Copy
```

#### 2.模拟IO操作

需求:控制LED灯亮度

原理:在1中LED灯只有关闭或开启两种状态，是无法控制 LED 灯亮度，如果要实现此功能，那么需要借助于 PWM(Pulse width modulation 脉冲宽度调制)技术，通过设置占空比为LED间歇性供电，PWM 的取值范围 [0,255]。

实现:

```cpp
/*
 * 需求:控制LED灯亮度
 * 实现:
 *  1.setup 中设置 led 灯的引脚为输出模式
 *  2.设置不同的 PWM 并输出
 * 
 */
int led = 13;
int l1 = 255;
int l2 = 50;
int l3 = 0;
void setup() {
  pinMode(led,OUTPUT);
}

void loop() {
  analogWrite(led,l1);
  delay(2000);
  analogWrite(led,l2);
  delay(2000);
  analogWrite(led,l3);
  delay(2000);

}
```

运行结果:在一个周期内LED灯亮度递减直至熄灭

### 8.2.5 arduino 基本语法演示03

需求:调用 millis() 函数获取程序当前已经执行的时间，调用delay()函数实现休眠

实现:

```cpp
/*
 * 需求:调用 millis() 函数获取程序当前已经执行的时间，调用delay()函数实现休眠
 * 
 * 1.setup 中设置波特率
 * 2.loop 中使用delay休眠，使用millis获取程序执行时间并输出
 * 
 */

unsigned long past_time;

void setup() {
  Serial.begin(57600);
}

void loop() {
  delay(2000);//休眠 2 秒

  past_time  = millis();
  Serial.println(past_time);  
}
Copy
```

通过串口监视器查看输出结果。

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/arduino%E6%97%B6%E9%97%B4.PNG)

## 8.3 机器人平台设计之电机驱动

对于构建轮式机器人而言，电机驱动是一重要实现环节。

> 场景:在机器人架构中，如果要实现机器人移动，其中一种实现策略是:控制系统会先发布预期的车辆速度信息，然后驱动系统订阅到该信息，不断调整电机转速直至达到预期速度，调速过程中还需要时时获取实际速度并反馈给控制系统，控制系统会计算实际位移并生成里程计信息。

在上述流程中，控制系统(ROS端)其实就是典型的发布和订阅实现，而具体到驱动系统(Arduino)层面，需要解决的问题有如下几点:

- 一个周期伊始，Arduino 如何订阅控制系统发布的速度相关信息？
- 一个周期结束，Arduino 如何发布实际速度相关信息到控制系统？
- 一个周期之中，Arduino 如何驱动电机(正传、反转)？
- 一个周期之中，Arduino 如何实现电机测速？
- 一个周期之中，Arduino 如何实现电机调速？

在整个闭环实现中，前两个问题涉及到驱动系统与控制系统的通信，其中控制系统会将串口通信的相关实现封装，暂时不需要关注，而Arduino端数据的接收与发送都可以通过之前介绍的 Serial 相关API实现，本节主要介绍后面三个问题的解决方式也即电机基本控制、电机测速以及电机调速实现，主要内容如下:

- 硬件:主要介绍电机类型与结构以及电机驱动板；
- 电机转向控制与电机转速的控制；
- 电机测速实现；
- 电机调速实现。

[
  ](http://www.autolabor.com.cn/book/ROSTutorials/di-8-zhang-gou-jian-lun-shi-cha-fen-ji-qi-ren/83-di-pan-kong-zhi-ji-chu-arduino-yu-dian-ji-qu-dong/831.html)

### 8.3.1 硬件_电机与电机驱动板

如果要通过Arduino实现电机相关操作(比如:转向控制、转速控制、测速等)，那么必须先要具备两点前提知识:

1. 需要简单了解电机类型、机械结构以及各项参数，这些是和机器人的负载、极限速度、测速结果等休戚相关的；
2. 还需要选配合适的电机驱动板，因为Arduino的输出电流不足以直接驱动电机，需要通过电机驱动板放大电机控制信号。

当前我们的机器人平台使用的电机为直流减速电机，电机驱动板为基于L298P实现的电路板。接下来就分别介绍这两个模块:

#### 1.直流减速电机

如图所示，相当一部分ROS智能车中使用的直流减速电机与之类似，主要由三部分构成:

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E7%94%B5%E6%9C%BA.jpg)

- 减速箱
- 电机主体
- 编码器

> 电机主体通过输入轴与减速箱相连接，通过减速箱的减速效果，最终外端的输出轴会按照比例(取决于减速箱减速比)降低电机输入轴的转速，当然速度降低之后，将提升电机的力矩。
>
> 尾部是AB相霍尔编码器，通过AB编码器输出的波形图，可以判断电机的转向以及计算电机转速

另外，即便电机外观相同，具体参数也可能存在差异，参数需要商家提供，需要了解的参数如下:

- 额定电压
- 额定电流
- 额定功率
- 额定扭矩
- 减速比
- 减速前转速
- 减速后转速
- 编码器精度

> 主要参数：
>
> 额定扭矩:额定扭矩和机器人质量以及有效负荷相关，二者正比例相关，额定扭矩越大，可支持的机器人质量以及有效负荷越高；
>
> 减速比:电机输入轴与输出轴的减速比例，比如: 减速比为90，意味着电机主体旋转90圈，输出轴旋转1圈。
>
> 减速后转速:与减速比相关，是电机减速箱输出轴的转速，单位是 rpm(转/分)，减速后转速与减速前转速存在转换关系: 减速后转速 = 减速前转速 / 减速比。另外，可以根据官方给定的额定功率下的减速后转速结合车轮参数来确定小车最大速度。
>
> 编码器精度:是指编码器旋转一圈单相(当前编码器有AB两相)输出的脉冲数；
> 注意:电机输入轴旋转一圈的同时，编码器旋转一圈，如果输出轴旋转一圈，那么编码器的旋转圈数和减速比一致(比如减速比是90，那么输出轴旋转一圈，编码器旋转90圈)。
> 编码器输出的脉冲数计算公式则是: 输出轴旋转一圈产生的脉冲数 = 减速比 * 编码器旋转一圈发送的脉冲数(比如:减速比为90，编码器旋转一圈输出11个脉冲，那么输出轴旋转一圈总共产生 11 * 90 也即990个脉冲)。

电机编码器![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E7%94%B5%E6%9C%BA%E7%BC%96%E7%A0%81%E5%99%A8.jpg)

> M1: 电机电源+(和M2对调可以正反转 )
>
> GND: 编码器电源-
>
> C2: 信号线
>
> C1: 信号线
>
> VCC:编码器电源+
>
> M2: 电机电源-(和M1对调可以正反转)

#### 2.电机驱动板

电机驱动板可选型号较多，比如:TB6612、L298N、L298P....但是这些电机驱动板与电机相连时，需要使用杜邦线，接线会显得凌乱，本节会采用一款基于L298P优化的电机驱动板，该驱动板可以使用端子线直接连接电机，接线更规整、美观。![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%9D%BF.jpg)

> 端子线母头对应的引脚(自上而下)
>
> 母头1: 4、地线、21、20、5V输入、 5
>
> 母头2: 7、地线、18、19、5V输入、 6

PS:电机驱动板使用时，需要打开USB接口处的电源开关。

#### 3.准备工作

组装底盘：集成电池、Arduino、电机驱动板与电机

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BA%95%E7%9B%98.jpg)

先安装Arduino、安装电机(接端子线)与万向轮，将电机驱动板与Arduino集成；

然后将电池的正负极分别接入电机驱动模块的12V与GND(注意:正负极不可接反，12V接红线，GND接黑线)；

最后将电机通过端子线与驱动板相连。

### 8.3.2 电机基本控制实现

在ROS智能车中，控制车辆的前进、后退以及速度调节，那么就涉及到电机的转向与转速控制，本节主要就是介绍相关知识点。

**需求:**控制单个电机转动，先控制电机以某个速率正向转动N秒，再让电机停止N秒，再控制电机以某个速率逆向转动N秒，最后让电机停止N秒，如此循环。

**实现流程:**

1. 编写Arduino程序，setup中设置引脚模式，loop中控制电机运动；
2. 上传并查看运行结果。

#### 1.编码

前提知识点：

1. 左电机的M1与M2对应的是引脚4(DIRA)和引脚5(PWMA)，引脚4控制转向，引脚5输出PWM。右电机的M1与M2对应的是引脚6(PWMB)和引脚7(DIRB)，引脚7控制转向，引脚6输出PWM。
2. 可以通过PWM控制电机转速。

**代码:**

```cpp
/*
 * 电机转动控制
 * 1.定义接线中电机对应的引脚
 * 2.setup 中设置引脚为输出模式
 * 3.loop中控制电机转动
 * 
 */

int DIRA = 9;
int PWMA = 10;

void setup() {
  //两个引脚都设置为 OUTPUT
  pinMode(DIRA,OUTPUT);
  pinMode(PWMA,OUTPUT);
}

void loop() {
  //先正向转动3秒
  digitalWrite(DIRA,HIGH);
  analogWrite(PWMA,100);
  delay(3000);
  //停止3秒
  digitalWrite(DIRA,LOW);
  analogWrite(PWMA,0);
  delay(3000);
  //再反向转动3秒
  digitalWrite(DIRA,LOW);
  analogWrite(PWMA,100);
  delay(3000);
  //停止3秒
  digitalWrite(DIRA,LOW);
  analogWrite(PWMA,0);
  delay(3000);

  /*
   * 注意: 
   * 1.可以通过将DIRA设置为HIGH或LOW来控制电机转向，但是哪个标志位正转或反转需要根据需求判断，转向是相对的。
   * 2.PWM的取值为 [0,255],该值可自己设置。
   * 
   */

}
```

#### 2.运行

程序上传到Arduino上，如无异常，电机开始转动，转动结果与需求描述类似。

### 8.3.3 电机测速01_理论

测速实现是调速实现的前提，本节主要介绍AB相增量式编码器测速原理。

#### 1.概念

百度百科关于编码器介绍如下:

编码器（encoder）是将信号（如比特流）或数据进行编制、转换为可用以通讯、传输和存储的信号形式的设备。编码器把角位移或直线位移转换成电信号，前者称为码盘，后者称为码尺。按照读出方式编码器可以分为接触式和非接触式两种；按照工作原理编码器可分为增量式和绝对式两类。增量式编码器是将位移转换成周期性的电信号，再把这个电信号转变成计数脉冲，用脉冲的个数表示位移的大小。绝对式编码器的每一个位置对应一个确定的数字码，因此它的示值只与测量的起始和终止位置有关，而与测量的中间过程无关。

#### 2.测速原理

关于编码器相关概念简单了解即可，在此需要着重介绍的是 AB相增量式编码器测速原理：
AB相编码器主要构成为A相与B相，每一相每转过单位的角度就发出一个脉冲信号(一圈可以发出N个脉冲信号)，A相、B相为相互延迟1/4周期的脉冲输出，根据延迟关系可以区别正反转，而且通过取A相、B相的上升和下降沿可以进行单频或2倍频或4倍频测速。

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/AB%E7%9B%B8.png)

#### 3.测速举例

假设编码器旋转1圈输出11个脉冲，减速比为 90。伪代码如下:

单频计数:

```cpp
//设置一个计数器
int count = 0;
//当A为上升沿时
if(B为高电平){
    count++;
}else {
    count--;
}
//....
//速度=单位时间内统计的脉冲的个数 / （11*90） / 单位时间
Copy
```

2倍频计数:

```cpp
//设置一个计数器
int count = 0;
//当A为上升沿时
if(B为高电平){
    count++;
}else {
    count--;
}
//当A为下降沿时
if(B为低电平){
    count++;
}else {
    count--;
}

//....
//速度=单位时间内统计的脉冲的个数 / （11*2*90） / 单位时间
Copy
```

4倍频计数:

```cpp
//设置一个计数器
int count = 0;
//当A为上升沿时
if(B为高电平){
    count++;
}else {
    count--;
}
//当A为下降沿时
if(B为低电平){
    count++;
}else {
    count--;
}
//当B为上升沿时
if(A为低电平){
    count++;
} else {
    count--;
}
//当B为下降沿时
if(A为高电平){
    count++;
} else {
    count--;
}
//....
//速度=单位时间内统计的脉冲的个数 / （11*4*90） / 单位时间
Copy
```

### 8.3.4 电机测速02_实现

**需求:**统计并输出电机转速。

**思路:**先统计单位时间内以单频或2倍频或4倍频的方式统计脉冲数，再除以一圈对应的脉冲数，最后再除以时间所得即为电机转速。

**核心:**计数时，需要在A相或B相的上升沿或下降沿触发时，实现计数，在此需要使用中断引脚与中断函数。

Arduino Mega 2560 的中断引脚:2 (interrupt 0), 3 (interrupt 1),18 (interrupt 5), 19 (interrupt 4), 20 (interrupt 3), 21 (interrupt 2)

**实现流程:**

1. 编写Arduino程序先实现脉冲数统计；
2. 编写Arduino程序再实现转速计算相关实现；
3. 上传到Arduino并测试。

#### 1.编码实现脉冲统计

核心知识点:**attachInterrupt()函数**(请参考 8.2.2 介绍)。

**代码:**

```cpp
/*
 * 测速实现:
 *  阶段1:脉冲数统计
 *  阶段2:速度计算
 * 
 * 阶段1:
 *  1.定义所使用的中断引脚,以及计数器(使用 volatile 修饰)
 *  2.setup 中设置波特率，将引脚设置为输入模式
 *  3.使用 attachInterupt() 函数为引脚添加中断出发时机以及中断函数
 *  4.中断函数编写计算算法，并打印
 *    A.单频统计只需要统计单相上升沿或下降沿
 *    B.2倍频统计需要统计单相的上升沿和下降沿
 *    C.4倍频统计需要统计两相的上升沿和下降沿
 *  5.上传并查看结果
 *  
 * 
 */
int motor_A = 2;//中断口是0
int motor_B = 3;//中断口是1
volatile int count = 0;//如果是正转，那么每计数一次自增1，如果是反转，那么每计数一次自减1 


void count_A(){
  //单频计数实现
  //手动旋转电机一圈，输出结果为 一圈脉冲数 * 减速比
  /*if(digitalRead(motor_A) == HIGH){

    if(digitalRead(motor_B) == LOW){//A 高 B 低
      count++;  
    } else {//A 高 B 高
      count--;  
    }


  }*/

  //2倍频计数实现
  //手动旋转电机一圈，输出结果为 一圈脉冲数 * 减速比 * 2
  if(digitalRead(motor_A) == HIGH){

    if(digitalRead(motor_B) == HIGH){//A 高 B 高
      count++;  
    } else {//A 高 B 低
      count--;  
    }


  } else {

    if(digitalRead(motor_B) == LOW){//A 低 B 低
      count++;  
    } else {//A 低 B 高
      count--;  
    }  

  }

}

//与A实现类似
//4倍频计数实现
//手动旋转电机一圈，输出结果为 一圈脉冲数 * 减速比 * 4
void count_B(){
  if(digitalRead(motor_B) == HIGH){

    if(digitalRead(motor_A) == LOW){//B 高 A 低
      count++;
    } else {//B 高 A 高
      count--;
    }


  } else {

    if(digitalRead(motor_A) == HIGH){//B 低 A 高
      count++;
    } else {//B 低 A 低
      count--;
    }

  }

}

void setup() {
  Serial.begin(57600);//设置波特率  
  pinMode(motor_A,INPUT);
  pinMode(motor_B,INPUT);
  attachInterrupt(0,count_A,CHANGE);//当电平发生改变时触发中断函数
  //四倍频统计需要为B相也添加中断
  //attachInterrupt(1,count_B,CHANGE);
}


void loop() {
  //测试计数器输出
  delay(2000);
  Serial.println(count);

}
```

#### 2.转速计算

思路:需要定义一个开始时间(用于记录每个测速周期的开始时刻)，还需要定义一个时间区间(比如50毫秒)，时时获取当前时刻，当当前时刻 - 上传结束时刻 >= 时间区间时，就获取当前计数并根据测速公式计算时时速度，计算完毕，计数器归零，重置开始时间

核心知识点:当使用中断函数中的变量时，需要先禁止中断**noInterrupts()**，调用完毕，再重启中断**interrupts()**(关于noInterrupts与interrupts请参考 8.2.2 介绍)。

**代码(核心):**

2中代码除了 loop 实现，无需修改。

```cpp
int reducation = 90;//减速比，根据电机参数设置，比如 15 | 30 | 60
int pulse = 11; //编码器旋转一圈产生的脉冲数该值需要参考商家电机参数
int per_round = pulse * reducation * 4;//车轮旋转一圈产生的脉冲数 
long start_time = millis();//一个计算周期的开始时刻，初始值为 millis();
long interval_time = 50;//一个计算周期 50ms
double current_vel;

//获取当前转速的函数
void get_current_vel(){
  long right_now = millis();  
  long past_time = right_now - start_time;//计算逝去的时间
  if(past_time >= interval_time){//如果逝去时间大于等于一个计算周期
    //1.禁止中断
    noInterrupts();
    //2.计算转速 转速单位可以是秒，也可以是分钟... 自定义即可
    current_vel = (double)count / per_round / past_time * 1000 * 60;
    //3.重置计数器
    count = 0;
    //4.重置开始时间
    start_time = right_now;
    //5.重启中断
    interrupts();

    Serial.println(current_vel);

  }
}

void loop() {

  delay(10);
  get_current_vel();

}
```

#### 3.测试

将代码上传至Arduino，打开出口监视器，手动旋转电机，可以查看到转速信息。

### 8.3.5 电机调速01_PID控制理论

> 场景:
>
> 速度信息可以以m/s为单位，或者也可以转换成转速 r/s，而电机的转速是由PWM脉冲宽度来控制的，如何根据速度信息量化成合适的PWM值呢？
>
> 比如:现有一辆行驶中的无人车，要求将车速调整至100KM/h，那么应该如何向电机输出PWM值？或换言之，如何控制油门？

调速实现策略由多种，PID其中较为常用。

#### PID简介

**PID算法是一种经典、简单、高效的动态速度调节方式，P代表比例，I代表积分，D代表微分。**

PID公式如下：

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/PID%E5%85%AC%E5%BC%8F.jpg)

- **e(t)**作为 PID 控制的输入；
- **u(t)**作为 PID 控制器的输出和被控对象的输入；
- **Kp** 控制器的比例系数；
- **Ki**控制器的积分时间，也称积分系数；
- **Kd**控制器的微分时间，也称微分系数。

上述公式稍显晦涩，PID控制原理框架图更有助于理解:

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/PID%E6%8E%A7%E5%88%B6.jpg)

##### 1.P

如果实现上述场景中的车速控制，一种简单的实现方式是: 确定目标速度，获取当前速度，使用`(目标速度-当前速度)*某一系数` 计算结果为输出的PWM，再获取当前速度，使用`(目标速度-当前速度)*某一系数` 计算结果为输出的PWM并输出...如此循环在上述模型中，调速实现是一个闭环，每一次循环都会根据当前时速与目标时速的差值，再乘以以固定系数，计算出需要输出的PWM值，这其中的系数，称之为比例。

![image-20231005120030938](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231005120030938.png)

##### 2.I

上述模型算法中，最终速度与预期速度存在稳态误差，这意味着最终结果可能永远无法达成预期，解决的方法就是使用积分I。每次调速时，输出的PWM还要累加根据积分I计算的结果，以消除静态误差。

![image-20231005120740380](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231005120740380.png)

##### 3.D

当I值设置的过大时，可能会出先"超速"的情况，超速之后可能需要多次调整，产生系统震荡，解决这种情况可以使用D微分，当速度越是接近目标速度时，D就会越施加反方向力，减弱P的控制，起到类似”阻尼“的作用。通过D的使用可以减小系统震荡。

![image-20231005121113941](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231005121113941.png)

------

综上，PID闭环控制实现是结合了比例、积分和微分的一种控制机制，通过P可以以比例的方式计算输出，通过I可以消除稳态误差，通过D可以减小系统震荡，三者相结合，最终是要快速、精准且稳定的达成预期结果，而要实现该结果，还需要对这三个数值反复测试、调整...下一节将介绍在 Arduino 中PID控制的具体实现，其中就包括PID库的调用，以及PID调试的具体方式。

### 8.3.6 电机调速02_PID控制实现

了解了PID原理以及计算公式之后，我们可以在程序中自实现PID相关算法实现，不过，在Arduino中该算法已经被封装了，直接整合调用即可，从而提高程序的安全性与开发效率。该库是:Arduino-PID-Library，接下来通过一个案例演示该库的使用。

**需求:**通过PID控制电机转速，预期转速为 80r/m。

**实现流程:**

1. 添加Arduino-PID-Library；
2. 编写Arduino程序直接调用相关实现；
3. 使用串口绘图器调试PID值。

#### 1.添加Arduino-PID-Library

首先在 GitHub 下载 PID 库: git clone https://github.com/br3ttb/Arduino-PID-Library

然后将该文件夹移动到 arduino 的 libraries下: sudo cp -r Arduino-PID-Library /home/用户xxx/Arduino/libraries

还要重命名文件夹: sudo mv Arduino-PID-Library ArduinoPIDLibrary

最后重启 ArduinoIDE

#### 2.编码

PID调速中，测速是实现闭环的关键实现，所以需要复制之前的电机控制代码以及测速代码。

完整代码实现:

```cpp
/*
 * PID 调速实现:
 * 1.代码准备，复制并修改电机控制以及测速代码
 * 2.包含PID头文件
 * 3.创建PID对象
 * 4.在setup中启用自动调试
 * 5.调试并更新PWM
 * 
 */

#include <PID_v1.h> 

int DIRA = 4;
int PWMA = 5;

int motor_A = 21;//中端口是2
int motor_B = 20;//中断口是3
volatile int count = 0;//如果是正转，那么每计数一次自增1，如果是反转，那么每计数一次自减1 


void count_A(){
  //单频计数实现
  //手动旋转电机一圈，输出结果为 一圈脉冲数 * 减速比
  /*if(digitalRead(motor_A) == HIGH){

    if(digitalRead(motor_B) == LOW){//A 高 B 低
      count++;  
    } else {//A 高 B 高
      count--;  
    }


  }*/

  //2倍频计数实现
  //手动旋转电机一圈，输出结果为 一圈脉冲数 * 减速比 * 2
  if(digitalRead(motor_A) == HIGH){

    if(digitalRead(motor_B) == HIGH){//A 高 B 高
      count++;  
    } else {//A 高 B 低
      count--;  
    }


  } else {

    if(digitalRead(motor_B) == LOW){//A 低 B 低
      count++;  
    } else {//A 低 B 高
      count--;  
    }  

  }

}

//与A实现类似
//4倍频计数实现
//手动旋转电机一圈，输出结果为 一圈脉冲数 * 减速比 * 4
void count_B(){
  if(digitalRead(motor_B) == HIGH){

    if(digitalRead(motor_A) == LOW){//B 高 A 低
      count++;
    } else {//B 高 A 高
      count--;
    }


  } else {

    if(digitalRead(motor_A) == HIGH){//B 低 A 高
      count++;
    } else {//B 低 A 低
      count--;
    }

  }

}


int reducation = 90;//减速比，根据电机参数设置，比如 15 | 30 | 60
int pulse = 11; //编码器旋转一圈产生的脉冲数该值需要参考商家电机参数
int per_round = pulse * reducation * 4;//车轮旋转一圈产生的脉冲数 
long start_time = millis();//一个计算周期的开始时刻，初始值为 millis();
long interval_time = 50;//一个计算周期 50ms
double current_vel;

//获取当前转速的函数
void get_current_vel(){
  long right_now = millis();  
  long past_time = right_now - start_time;//计算逝去的时间
  if(past_time >= interval_time){//如果逝去时间大于等于一个计算周期
    //1.禁止中断
    noInterrupts();
    //2.计算转速 转速单位可以是秒，也可以是分钟... 自定义即可
    current_vel = (double)count / per_round / past_time * 1000 * 60;
    //3.重置计数器
    count = 0;
    //4.重置开始时间
    start_time = right_now;
    //5.重启中断
    interrupts();

    Serial.println(current_vel);

  }
}

//-------------------------------------PID-------------------------------------------
//创建 PID 对象
//1.当前转速 2.计算输出的pwm 3.目标转速 4.kp 5.ki 6.kd 7.当输入与目标值出现偏差时，向哪个方向控制
double pwm;//电机驱动的PWM值
double target = 80;
double kp=1.5, ki=3.0, kd=0.1;
PID pid(&current_vel,&pwm,&target,kp,ki,kd,DIRECT);

//速度更新函数
void update_vel(){
  //获取当前速度
  get_current_vel();
  pid.Compute();//计算需要输出的PWM
  digitalWrite(DIRA,HIGH);
  analogWrite(PWMA,pwm);

}

void setup() {
  Serial.begin(57600);//设置波特率  
  pinMode(18,INPUT);
  pinMode(19,INPUT);
  //两个电机驱动引脚都设置为 OUTPUT
  pinMode(DIRA,OUTPUT);
  pinMode(PWMA,OUTPUT);

  attachInterrupt(2,count_A,CHANGE);//当电平发生改变时触发中断函数
  //四倍频统计需要为B相也添加中断
  attachInterrupt(3,count_B,CHANGE);

  pid.SetMode(AUTOMATIC);
}



void loop() {
  delay(10);
  update_vel();

}
```

核心代码解释:

1.包含PID头文件

```cpp
#include <PID_v1.h>
```

2.创建PID对象

```cpp
//创建 PID 对象
//1.当前转速 2.计算输出的pwm 3.目标转速 4.kp 5.ki 6.kd 7.当输入与目标值出现偏差时，向哪个方向控制
double pwm;//电机驱动的PWM值
double target = 120;
double kp=1.5, ki=3.0, kd=0.1;
PID pid(&current_vel,&pwm,&target,kp,ki,kd,DIRECT);
```

3.setup中启用PID自动控制

```cpp
pid.SetMode(AUTOMATIC);
```

4.计算输出值

```cpp
pid.Compute();
```

#### 4.调试

PID控制的最终预期结果，是要快速、精准、稳定的达成预期结果，P主要用于控制响应速度，I主要用于控制精度，D主要用于减小震荡增强系统稳定性，三者的取值是需要反复调试的，调试过程中需要查看系统的响应曲线，根据响应曲线以确定合适的PID值。

在 Arduino 中响应曲线的查看可以借助于 Serial.println() 将结果输出，然后再选择菜单栏的工具下串口绘图器以图形化的方式显示响应结果:![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/PID%E8%B0%83%E8%AF%95.png)PID调试技巧:

参数整定找最佳，从小到大顺序查

先是比例后积分，最后再专把微分加

曲线振属荡很频繁，比例度盘要放大

曲线漂浮绕大湾，比例度盘往小扳

曲线偏离回复慢，积分时间往下降

曲线波动周期长，积分时间再加长

曲线振荡频率快，先把微分降下来

动差大来波动慢。微分时间应加长

理想曲线两个波，前高后低4比1

一看二调多分析，调节质量不会低

## 8.4 机器人平台设计之底盘实现

在ros中还提供了一个已经封装了的模块: ros_arduino_bridge，该模块由下位机驱动和上位机控制两部分组成，通过该模块可以更为快捷、方便的实现自己的机器人平台。本节介绍的主要内容如下:

- ros_arduino_bridge 的架构；
- 下位机端 Arduino 程序修改。

注意:官方提供的案例所需硬件国内不易购买，需要修改源码适配当前硬件。

### 8.4.1 底盘实现_概述

#### 1.ros_arduino_bridge 简介

该功能包包含Arduino库和用来控制Arduino的ROS驱动包，它旨在成为在ROS下运行Arduino控制的机器人的完整解决方案。

其中当前主要关注的是:功能包集中一个兼容不同驱动的机器人的基本控制器（base controller），它可以接收ROS Twist类型的消息，可以发布里程计数据。

**特点:**

- 可以直接支持ping声呐和Sharp红外线传感器；
- 也可以从通用的模拟和数字信号的传感器读取数据；
- 可以控制数字信号的输出；
- 支持PWM伺服机；
- 如果使用所要求的硬件的话，可以配置基本功能；
- 如果你的Arduino编程基础好的话，并且具有python基础的话，你就可以很自由的改动代码来满足你的硬件要求。

**注意：**

- 官方提供的部分硬件不易采购，需要修改下位机程序，以适配当前硬件。

**系统要求:**

- 如果只是安装调试下位机，那么不必须安装ROS系统，只要有 arduino 开发环境即可；
- 而上位机调试，适用于 ROS Indigo 及更高版本，但是暂不支持最新版本 noetic，所以上位机需要使用其它版本的ROS(建议 melodic)；

**下载:**

进入ROS工作空间的src目录,输入命令:

```
git clone https://github.com/hbrobotics/ros_arduino_bridge.git
```

#### 2.ros_arduino_bridge 架构

文件结构说明

```
├── ros_arduino_bridge                      # metapackage (元功能包)
│   ├── CMakeLists.txt
│   └── package.xml
├── ros_arduino_firmware                    #固件包，更新到Arduino
│   ├── CMakeLists.txt
│   ├── package.xml
│   └── src
│       └── libraries                       #库目录
│           ├── MegaRobogaiaPololu          #针对Pololu电机控制器，MegaRobogaia编码器的头文件定义
│           │   ├── commands.h              #定义命令头文件
│           │   ├── diff_controller.h       #差分轮PID控制头文件
│           │   ├── MegaRobogaiaPololu.ino  #PID实现文件
│           │   ├── sensors.h               #传感器相关实现，超声波测距，Ping函数
│           │   └── servos.h                #伺服器头文件
│           └── ROSArduinoBridge            #Arduino相关库定义
│               ├── commands.h              #定义命令
│               ├── diff_controller.h       #差分轮PID控制头文件
│               ├── encoder_driver.h        #编码器驱动头文件
│               ├── encoder_driver.ino      #编码器驱动实现, 读取编码器数据，重置编码器等
│               ├── motor_driver.h          #电机驱动头文件
│               ├── motor_driver.ino        #电机驱动实现，初始化控制器，设置速度
│               ├── ROSArduinoBridge.ino    #核心功能实现，程序入口
│               ├── sensors.h               #传感器头文件及实现
│               ├── servos.h                #伺服器头文件，定义插脚，类
│               └── servos.ino              #伺服器实现
├── ros_arduino_msgs                        #消息定义包
│   ├── CMakeLists.txt
│   ├── msg                                 #定义消息
│   │   ├── AnalogFloat.msg                 #定义模拟IO浮点消息
│   │   ├── Analog.msg                      #定义模拟IO数字消息
│   │   ├── ArduinoConstants.msg            #定义常量消息
│   │   ├── Digital.msg                     #定义数字IO消息
│   │   └── SensorState.msg                 #定义传感器状态消息
│   ├── package.xml
│   └── srv                                 #定义服务
│       ├── AnalogRead.srv                  #模拟IO输入
│       ├── AnalogWrite.srv                 #模拟IO输出
│       ├── DigitalRead.srv                 #数字IO输入
│       ├── DigitalSetDirection.srv　　　　 #数字IO设置方向
│       ├── DigitalWrite.srv                #数字IO输入
│       ├── ServoRead.srv                   #伺服电机输入
│       └── ServoWrite.srv                  #伺服电机输出
└── ros_arduino_python                      #ROS相关的Python包，用于上位机，树莓派等开发板或电脑等。
    ├── CMakeLists.txt
    ├── config                              #配置目录
    │   └── arduino_params.yaml             #定义相关参数，端口，rate，PID，sensors等默认参数。由arduino.launch调用
    ├── launch
    │   └── arduino.launch                  #启动文件
    ├── nodes
    │   └── arduino_node.py                 #python文件,实际处理节点，由arduino.launch调用，即可单独调用。
    ├── package.xml
    ├── setup.py
    └── src                                 #Python类包目录
        └── ros_arduino_python
            ├── arduino_driver.py           #Arduino驱动类
            ├── arduino_sensors.py          #Arduino传感器类
            ├── base_controller.py          #基本控制类，订阅cmd_vel话题，发布odom话题
            └── __init__.py                 #类包默认空文件
Copy
```

上述目录结构虽然复杂，但是关注的只有两大部分:

- ros_arduino_bridge/ros_arduino_firmware/src/libraries/ROSArduinoBridge
- ros_arduino_bridge/ros_arduino_python/config/arduino_params.yaml

前者是Arduino端的固件包实现，需要修改并上传至Arduino电路板；

后者是ROS端的一个配置文件，相关驱动已经封装完毕，我们只需要修改配置信息即可。

整体而言，借助于 ros_arduino_bridge可以大大提高我们的开发效率。

#### 3.案例实现

基于ros_arduino_bridge的底盘实现具体步骤如下:

- 了解并修改Arduino端程序主入口ROSArduinoBridge.ino 文件；
- Arduino端添加编码器驱动；
- Arduino端添加电机驱动模块；
- Arduino端实现PID调试；

### 8.4.2 底盘实现_01Arduino端入口

ros_arduino_bridge/ros_arduino_firmware/src/libraries/ROSArduinoBridge下的RosArduinoBridge.ino是Arduino端程序的主入口，

源文件(添加中文注释)内容如下:

```cpp
/*********************************************************************
 *  ROSArduinoBridge
    可以通过一组简单的串口命令来控制差分机器人并接收回传的传感器与里程计
    数据，默认使用的是 Arduino Mega + Pololu电机驱动模块，如果使用其他的
    编码器或电机驱动需要重写readEncoder()与setMotorSpeed()函数
    A set of simple serial commands to control a differential drive
    robot and receive back sensor and odometry data. Default 
    configuration assumes use of an Arduino Mega + Pololu motor
    controller shield + Robogaia Mega Encoder shield.  Edit the
    readEncoder() and setMotorSpeed() wrapper functions if using 
    different motor controller or encoder method.

    Created for the Pi Robot Project: http://www.pirobot.org
    and the Home Brew Robotics Club (HBRC): http://hbrobotics.org

    Authors: Patrick Goebel, James Nugen

    Inspired and modeled after the ArbotiX driver by Michael Ferguson

    Software License Agreement (BSD License)

    Copyright (c) 2012, Patrick Goebel.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above
       copyright notice, this list of conditions and the following
       disclaimer in the documentation and/or other materials provided
       with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *********************************************************************/
//是否启用基座控制器
//#define USE_BASE      // Enable the base controller code
#undef USE_BASE     // Disable the base controller code

/* Define the motor controller and encoder library you are using */
//启用基座控制器需要设置的电机驱动以及编码器驱动
#ifdef USE_BASE
   /* The Pololu VNH5019 dual motor driver shield */
   #define POLOLU_VNH5019

   /* The Pololu MC33926 dual motor driver shield */
   //#define POLOLU_MC33926

   /* The RoboGaia encoder shield */
   #define ROBOGAIA

   /* Encoders directly attached to Arduino board */
   //#define ARDUINO_ENC_COUNTER

   /* L298 Motor driver*/
   //#define L298_MOTOR_DRIVER
#endif

//是否启用舵机
#define USE_SERVOS  // Enable use of PWM servos as defined in servos.h
//#undef USE_SERVOS     // Disable use of PWM servos

/* Serial port baud rate */
//波特率
#define BAUDRATE     57600

/* Maximum PWM signal */
//最大PWM值
#define MAX_PWM        255

//根据Arduino型号来包含对应的头文件
#if defined(ARDUINO) && ARDUINO >= 100
#include "Arduino.h"
#else
#include "WProgram.h"
#endif

/* Include definition of serial commands */
//串口命令
#include "commands.h"

/* Sensor functions */
//传感器文件
#include "sensors.h"

/* Include servo support if required */
//如果启用舵机，需要包含的头文件
#ifdef USE_SERVOS
   #include <Servo.h>
   #include "servos.h"
#endif

//如果启用基座控制器需要包含的头文件
#ifdef USE_BASE
  /* Motor driver function definitions */
  #include "motor_driver.h" //电机驱动

  /* Encoder driver function definitions */
  #include "encoder_driver.h"  //编码器驱动

  /* PID parameters and functions */
  #include "diff_controller.h" //PID调速

  /* Run the PID loop at 30 times per second */
  #define PID_RATE           30     // Hz 调速频率

  /* Convert the rate into an interval */
  const int PID_INTERVAL = 1000 / PID_RATE; //调速周期

  /* Track the next time we make a PID calculation */
  unsigned long nextPID = PID_INTERVAL;

  /* Stop the robot if it hasn't received a movement command
   in this number of milliseconds */
  #define AUTO_STOP_INTERVAL 2000 //自动结束时间(可按需修改)
  long lastMotorCommand = AUTO_STOP_INTERVAL;
#endif

/* Variable initialization */

// A pair of varibles to help parse serial commands (thanks Fergs)
int arg = 0;
int index = 0;

// Variable to hold an input character
char chr;

// Variable to hold the current single-character command
char cmd;

// Character arrays to hold the first and second arguments
char argv1[16];
char argv2[16];

// The arguments converted to integers
long arg1;
long arg2;

/* Clear the current command parameters */
//重置命令
void resetCommand() {
  cmd = NULL;
  memset(argv1, 0, sizeof(argv1));
  memset(argv2, 0, sizeof(argv2));
  arg1 = 0;
  arg2 = 0;
  arg = 0;
  index = 0;
}

/* Run a command.  Commands are defined in commands.h */
//执行串口命令
int runCommand() {
  int i = 0;
  char *p = argv1;
  char *str;
  int pid_args[4];
  arg1 = atoi(argv1);
  arg2 = atoi(argv2);

  switch(cmd) {
  case GET_BAUDRATE:
    Serial.println(BAUDRATE);
    break;
  case ANALOG_READ:
    Serial.println(analogRead(arg1));
    break;
  case DIGITAL_READ:
    Serial.println(digitalRead(arg1));
    break;
  case ANALOG_WRITE:
    analogWrite(arg1, arg2);
    Serial.println("OK"); 
    break;
  case DIGITAL_WRITE:
    if (arg2 == 0) digitalWrite(arg1, LOW);
    else if (arg2 == 1) digitalWrite(arg1, HIGH);
    Serial.println("OK"); 
    break;
  case PIN_MODE:
    if (arg2 == 0) pinMode(arg1, INPUT);
    else if (arg2 == 1) pinMode(arg1, OUTPUT);
    Serial.println("OK");
    break;
  case PING:
    Serial.println(Ping(arg1));
    break;
#ifdef USE_SERVOS
  case SERVO_WRITE:
    servos[arg1].setTargetPosition(arg2);
    Serial.println("OK");
    break;
  case SERVO_READ:
    Serial.println(servos[arg1].getServo().read());
    break;
#endif

#ifdef USE_BASE
  case READ_ENCODERS:
    Serial.print(readEncoder(LEFT));
    Serial.print(" ");
    Serial.println(readEncoder(RIGHT));
    break;
   case RESET_ENCODERS:
    resetEncoders();
    resetPID();
    Serial.println("OK");
    break;
  case MOTOR_SPEEDS: //传入电机控制命令
    /* Reset the auto stop timer */
    lastMotorCommand = millis();
    if (arg1 == 0 && arg2 == 0) {
      setMotorSpeeds(0, 0);
      resetPID();
      moving = 0;
    }
    else moving = 1;
    leftPID.TargetTicksPerFrame = arg1;
    rightPID.TargetTicksPerFrame = arg2;
    Serial.println("OK"); 
    break;
  case UPDATE_PID:
    while ((str = strtok_r(p, ":", &p)) != '\0') {
       pid_args[i] = atoi(str);
       i++;
    }
    Kp = pid_args[0];
    Kd = pid_args[1];
    Ki = pid_args[2];
    Ko = pid_args[3];
    Serial.println("OK");
    break;
#endif
  default:
    Serial.println("Invalid Command");
    break;
  }
}

/* Setup function--runs once at startup. */
void setup() {
  Serial.begin(BAUDRATE);

// Initialize the motor controller if used */
#ifdef USE_BASE
  #ifdef ARDUINO_ENC_COUNTER
    //set as inputs
    DDRD &= ~(1<<LEFT_ENC_PIN_A);
    DDRD &= ~(1<<LEFT_ENC_PIN_B);
    DDRC &= ~(1<<RIGHT_ENC_PIN_A);
    DDRC &= ~(1<<RIGHT_ENC_PIN_B);

    //enable pull up resistors
    PORTD |= (1<<LEFT_ENC_PIN_A);
    PORTD |= (1<<LEFT_ENC_PIN_B);
    PORTC |= (1<<RIGHT_ENC_PIN_A);
    PORTC |= (1<<RIGHT_ENC_PIN_B);

    // tell pin change mask to listen to left encoder pins
    PCMSK2 |= (1 << LEFT_ENC_PIN_A)|(1 << LEFT_ENC_PIN_B);
    // tell pin change mask to listen to right encoder pins
    PCMSK1 |= (1 << RIGHT_ENC_PIN_A)|(1 << RIGHT_ENC_PIN_B);

    // enable PCINT1 and PCINT2 interrupt in the general interrupt mask
    PCICR |= (1 << PCIE1) | (1 << PCIE2);
  #endif
  initMotorController(); //初始化电机控制
  resetPID(); //重置 PID
#endif

/* Attach servos if used */
  #ifdef USE_SERVOS
    int i;
    for (i = 0; i < N_SERVOS; i++) {
      servos[i].initServo(
          servoPins[i],
          stepDelay[i],
          servoInitPosition[i]);
    }
  #endif
}

/* Enter the main loop.  Read and parse input from the serial port
   and run any valid commands. Run a PID calculation at the target
   interval and check for auto-stop conditions.
*/
void loop() {
  //读取串口命令
  while (Serial.available() > 0) {

    // Read the next character
    chr = Serial.read();

    // Terminate a command with a CR
    if (chr == 13) {
      if (arg == 1) argv1[index] = NULL;
      else if (arg == 2) argv2[index] = NULL;
      runCommand();
      resetCommand();
    }
    // Use spaces to delimit parts of the command
    else if (chr == ' ') {
      // Step through the arguments
      if (arg == 0) arg = 1;
      else if (arg == 1)  {
        argv1[index] = NULL;
        arg = 2;
        index = 0;
      }
      continue;
    }
    else {
      if (arg == 0) {
        // The first arg is the single-letter command
        cmd = chr;
      }
      else if (arg == 1) {
        // Subsequent arguments can be more than one character
        argv1[index] = chr;
        index++;
      }
      else if (arg == 2) {
        argv2[index] = chr;
        index++;
      }
    }
  }

// If we are using base control, run a PID calculation at the appropriate intervals
#ifdef USE_BASE
  if (millis() > nextPID) {
    updatePID();//PID调速
    nextPID += PID_INTERVAL;
  }

  // Check to see if we have exceeded the auto-stop interval
  if ((millis() - lastMotorCommand) > AUTO_STOP_INTERVAL) {;
    setMotorSpeeds(0, 0);
    moving = 0;
  }
#endif

// Sweep servos
#ifdef USE_SERVOS
  int i;
  for (i = 0; i < N_SERVOS; i++) {
    servos[i].doSweep();
  }
#endif
}
Copy
```

这其中，需要关注的是基座控制器以及串口命令的相关部分，而由于没有使用舵机，所以舵机控制器部分暂不介绍。

#### 1.串口命令

在主程序中，包含了 commands.h，该文件中包含了当前程序预定义的串口命令，可以编译程序并上传至 Arduino 电路板，然后打开串口监视器测试(当前程序并未修改，所以并非所有串口可用):

- w 可以用于控制引脚电平
- x 可以用于模拟输出

以LED灯控制为例，通过串口监视器录入命令:

- w 13 0 == LED灯关闭
- w 13 1 == LED灯打开
- x 13 50 == LED灯PWM值为50

#### 2.启用基座控制器

源码默认没有启用基座控制器、启用了舵机，我们需要启用基座控制器，禁用舵机。修改后代码如下:

```cpp
#define USE_BASE      // Enable the base controller code
//#undef USE_BASE     // Disable the base controller code

/* Define the motor controller and encoder library you are using */
#ifdef USE_BASE
   /* The Pololu VNH5019 dual motor driver shield */
   //#define POLOLU_VNH5019

   /* The Pololu MC33926 dual motor driver shield */
   //#define POLOLU_MC33926

   /* The RoboGaia encoder shield */
   //#define ROBOGAIA

   /* Encoders directly attached to Arduino board */
   //#define ARDUINO_ENC_COUNTER

   /* L298 Motor driver*/
   //#define L298_MOTOR_DRIVER
#endif

//#define USE_SERVOS  // Enable use of PWM servos as defined in servos.h
#undef USE_SERVOS     // Disable use of PWM servos
```

注意:我们没有使用官方的电机驱动模块以及编码器，后期需要自定义电机驱动与编码器实现。

### 8.4.3 底盘实现_02Arduino端编码器驱动

测速是整个PID闭环控制中的必须环节，我们必须修改代码适配当前AB相编码器，虽然需要重写功能，但是测速部分内容已经封装，只需要实现编码器计数即可，大致实现流程如下:

1. ROSArduinoBridge.ino 中需要注释之前的编码器驱动，添加自定义编码器驱动；
2. encoder_driver.h 中设置编码器引脚并声明初始化函数以及中断函数；
3. encoder_driver.ino 中实现编码器计数以及重置函数；
4. ROSArduinoBridge.ino 中 setup 函数调用编码器初始化函数。
5. 测试

#### 1.定义编码器驱动

ROSArduinoBridge.ino需要添加编码器宏定义,代码如下:

```cpp
#define USE_BASE      // Enable the base controller code
//#undef USE_BASE     // Disable the base controller code

/* Define the motor controller and encoder library you are using */
#ifdef USE_BASE
   /* The Pololu VNH5019 dual motor driver shield */
   //#define POLOLU_VNH5019

   /* The Pololu MC33926 dual motor driver shield */
   //#define POLOLU_MC33926

   /* The RoboGaia encoder shield */
   //#define ROBOGAIA

   /* Encoders directly attached to Arduino board */
   //#define ARDUINO_ENC_COUNTER
   #define ARDUINO_MY_COUNTER

   /* L298 Motor driver*/
   //#define L298_MOTOR_DRIVER

   #define L298P_MOTOR_DRIVER
#endif
```

先去除 #define L298P_MOTOR_DRIVER 的注释，否则后续编译会抛出异常。

#### 2.修改encoder_driver.h文件

修改后内容如下:

```cpp
/* *************************************************************
   Encoder driver function definitions - by James Nugen
   ************************************************************ */


#ifdef ARDUINO_ENC_COUNTER
  //below can be changed, but should be PORTD pins; 
  //otherwise additional changes in the code are required
  #define LEFT_ENC_PIN_A PD2  //pin 2
  #define LEFT_ENC_PIN_B PD3  //pin 3

  //below can be changed, but should be PORTC pins
  #define RIGHT_ENC_PIN_A PC4  //pin A4
  #define RIGHT_ENC_PIN_B PC5   //pin A5
#elif defined ARDUINO_MY_COUNTER
  #define LEFT_A 21
  #define LEFT_B 20
  #define RIGHT_A 18
  #define RIGHT_B 19
  void initEncoders();
  void leftEncoderEventA();
  void leftEncoderEventB();
  void rightEncoderEventA();
  void rightEncoderEventB();
#endif

long readEncoder(int i);
void resetEncoder(int i);
void resetEncoders();
```

#### 3.修改encoder_driver.ino 文件

主要添加内容如下:

```cpp
#elif defined ARDUINO_MY_COUNTER
  volatile long left_count = 0L;
  volatile long right_count = 0L;
  void initEncoders(){
    pinMode(LEFT_A,INPUT); // 21  --- 2
    pinMode(LEFT_B,INPUT); // 20  --- 3
    pinMode(RIGHT_A,INPUT);// 18  --- 5
    pinMode(RIGHT_B,INPUT);// 19  --- 4

    attachInterrupt(2,leftEncoderEventA,CHANGE);
    attachInterrupt(3,leftEncoderEventB,CHANGE);
    attachInterrupt(5,rightEncoderEventA,CHANGE);
    attachInterrupt(4,rightEncoderEventB,CHANGE);
  }
  void leftEncoderEventA(){
    if(digitalRead(LEFT_A) == HIGH){
      if(digitalRead(LEFT_B) == HIGH){
        left_count++;
      } else {
        left_count--;
      }
    } else {
      if(digitalRead(LEFT_B) == LOW){
        left_count++;
      } else {
        left_count--;
      }
    }
  }
  void leftEncoderEventB(){
    if(digitalRead(LEFT_B) == HIGH){
      if(digitalRead(LEFT_A) == LOW){
        left_count++;
      } else {
        left_count--;
      }
    } else {
      if(digitalRead(LEFT_A) == HIGH){
        left_count++;
      } else {
        left_count--;
      }
    }
  }
  void rightEncoderEventA(){
    if(digitalRead(RIGHT_A) == HIGH){
      if(digitalRead(RIGHT_B) == HIGH){
        right_count++;
      } else {
        right_count--;
      }
    } else {
      if(digitalRead(RIGHT_B) == LOW){
        right_count++;
      } else {
        right_count--;
      }
    }  
  }
  void rightEncoderEventB(){
     if(digitalRead(RIGHT_B) == HIGH){
      if(digitalRead(RIGHT_A) == LOW){
        right_count++;
      } else {
        right_count--;
      }
    } else {
      if(digitalRead(RIGHT_A) == HIGH){
        right_count++;
      } else {
        right_count--;
      }
    }  
  }

  long readEncoder(int i) {
    if (i == LEFT) return left_count;
    else return right_count;
  }

  /* Wrap the encoder reset function */
  void resetEncoder(int i) {
    if (i == LEFT){
      left_count=0L;
      return;
    } else { 
      right_count=0L;
      return;
    }
  }
```

#### 4.ROSArduinoBridge.ino 实现初始化

setup 添加语句:initEncoders();

```cpp
void setup() {
  Serial.begin(BAUDRATE);

// Initialize the motor controller if used */
#ifdef USE_BASE
  #ifdef ARDUINO_ENC_COUNTER
    //set as inputs
    DDRD &= ~(1<<LEFT_ENC_PIN_A);
    DDRD &= ~(1<<LEFT_ENC_PIN_B);
    DDRC &= ~(1<<RIGHT_ENC_PIN_A);
    DDRC &= ~(1<<RIGHT_ENC_PIN_B);

    //enable pull up resistors
    PORTD |= (1<<LEFT_ENC_PIN_A);
    PORTD |= (1<<LEFT_ENC_PIN_B);
    PORTC |= (1<<RIGHT_ENC_PIN_A);
    PORTC |= (1<<RIGHT_ENC_PIN_B);

    // tell pin change mask to listen to left encoder pins
    PCMSK2 |= (1 << LEFT_ENC_PIN_A)|(1 << LEFT_ENC_PIN_B);
    // tell pin change mask to listen to right encoder pins
    PCMSK1 |= (1 << RIGHT_ENC_PIN_A)|(1 << RIGHT_ENC_PIN_B);

    // enable PCINT1 and PCINT2 interrupt in the general interrupt mask
    PCICR |= (1 << PCIE1) | (1 << PCIE2);
  #elif defined ARDUINO_MY_COUNTER
    initEncoders();
  #endif
  initMotorController();
  resetPID();
#endif

/* Attach servos if used */
  #ifdef USE_SERVOS
    int i;
    for (i = 0; i < N_SERVOS; i++) {
      servos[i].initServo(
          servoPins[i],
          stepDelay[i],
          servoInitPosition[i]);
    }
  #endif



}
Copy
```

#### 5.测试

编译并上传程序，打开串口监视器，然后旋转车轮，在串口监视器中录入 e 即可查看左右编码器计数，录入命令 r 可以重置计数。

![image-20231107171721770](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231107171721770.png)

### 8.4.4 底盘实现_03Arduino端电机驱动

自定义电机驱动的实现与上一节的编码器驱动流程类似:

1. ROSArduinoBridge.ino 中需要注释之前的电机驱动，添加自定义电机驱动；
2. motor_driver.h 中设置左右电机引脚；
3. motor_driver.ino 中实现初始化与速度设置函数；
4. 测试

#### 1.定义电机驱动

ROSArduinoBridge.ino需要添加电机宏定义,代码如下:

```cpp
#define USE_BASE      // Enable the base controller code
//#undef USE_BASE     // Disable the base controller code

/* Define the motor controller and encoder library you are using */
#ifdef USE_BASE
   /* The Pololu VNH5019 dual motor driver shield */
   //#define POLOLU_VNH5019

   /* The Pololu MC33926 dual motor driver shield */
   //#define POLOLU_MC33926

   /* The RoboGaia encoder shield */
   //#define ROBOGAIA

   /* Encoders directly attached to Arduino board */
   //#define ARDUINO_ENC_COUNTER
   /* 使用自定义的编码器驱动 */
   #define ARDUINO_MY_COUNTER

   /* L298 Motor driver*/
   //#define L298_MOTOR_DRIVER
   //使用自定义的L298P电机驱动
   #define L298P_MOTOR_DRIVER
#endif
Copy
```

#### 2.修改motor_driver.h文件

修改后内容如下:

```cpp
/***************************************************************
   Motor driver function definitions - by James Nugen
   *************************************************************/

#ifdef L298_MOTOR_DRIVER
  #define RIGHT_MOTOR_BACKWARD 5
  #define LEFT_MOTOR_BACKWARD  6
  #define RIGHT_MOTOR_FORWARD  9
  #define LEFT_MOTOR_FORWARD   10
  #define RIGHT_MOTOR_ENABLE 12
  #define LEFT_MOTOR_ENABLE 13
#elif defined L298P_MOTOR_DRIVER
  #define DIRA 4
  #define PWMA 5
  #define DIRB 7
  #define PWMB 6
#endif

void initMotorController();
void setMotorSpeed(int i, int spd);
void setMotorSpeeds(int leftSpeed, int rightSpeed);
Copy
```

#### 3.修改motor_driver.ino 文件

主要添加内容如下:

```cpp
#elif defined L298P_MOTOR_DRIVER
  void initMotorController(){
    pinMode(DIRA,OUTPUT);
    pinMode(PWMA,OUTPUT);
    pinMode(DIRB,OUTPUT);
    pinMode(PWMB,OUTPUT);
  }
  void setMotorSpeed(int i, int spd){
    unsigned char reverse = 0;

    if (spd < 0)
    {
      spd = -spd;
      reverse = 1;
    }
    if (spd > 255)
      spd = 255;

    if (i == LEFT) { 
      if (reverse == 0) { 
        digitalWrite(DIRA,HIGH);
      } else if (reverse == 1) { 
        digitalWrite(DIRA,LOW);
      }
      analogWrite(PWMA,spd);
    } else /*if (i == RIGHT) //no need for condition*/ {
      if (reverse == 0) { 
        digitalWrite(DIRB,LOW);        
      } else if (reverse == 1) { 
        digitalWrite(DIRB,HIGH);
      }
      analogWrite(PWMB,spd);
    }
  }
  void setMotorSpeeds(int leftSpeed, int rightSpeed){
    setMotorSpeed(LEFT, leftSpeed);
    setMotorSpeed(RIGHT, rightSpeed);
  }
Copy
```

#### 4.测试

编译并上传程序，打开串口监视器，然后输入命令，命令格式为: m num1 num2，num1和num2分别为单位时间内左右电机各自转动的编码器计数，而默认单位时间为 1/30 秒。

> 举例，假设车轮旋转一圈编码器计数为 3960(减速比90，编码器分辨率11且采用4倍频计数)，当输入命令为 m 200 100 时：
>
> 左电机转速为: 200 * 30 * 60 / 3960 = 90.9 (r/m)
>
> 右电机转速为: 100 * 30 * 60 / 3960 = 45.45 (r/m)

### 8.4.5 底盘实现_04Arduino端PID控制

上一节最后测试时，电机可能会出现抖动、顿挫的现象，显而易见的这是由于PID参数设置不合理导致的，本节将介绍ros_arduino_bridge中的PID调试，大致流程如下:

1. 了解ros_arduino_bridge中PID调试的流程；
2. 实现PID调试。

#### 1.ros_arduino_bridge中PID调试源码分析

基本思想:

1. 先定义调试频率(周期)，并预先设置下一次的结束时刻；
2. 当当前时刻大于预设的结束时刻时，即进行PID调试，且重置下一次调试结束时刻
3. PID代码在diff_controller中实现，PID的目标值是命令输入的转速，当前转速则是通过读取当前编码器计数再减去上一次调试结束时记录的编码器计数获取；
4. 最后输出 PWM

ROSArduinoBridge.ino 中和PID控制相关的变量:

```cpp
#ifdef USE_BASE
  /* Motor driver function definitions */
  #include "motor_driver.h"

  /* Encoder driver function definitions */
  #include "encoder_driver.h"

  /* PID parameters and functions */
  #include "diff_controller.h"

  /* Run the PID loop at 30 times per second */
  #define PID_RATE           30     // Hz PID调试频率

  /* Convert the rate into an interval */
  const int PID_INTERVAL = 1000 / PID_RATE; // PID调试周期

  /* Track the next time we make a PID calculation */
  unsigned long nextPID = PID_INTERVAL; //PID调试的结束时刻标记

  /* Stop the robot if it hasn't received a movement command
   in this number of milliseconds */
  #define AUTO_STOP_INTERVAL 5000
  long lastMotorCommand = AUTO_STOP_INTERVAL;
#endif
Copy
```

ROSArduinoBridge.ino 的 runCommand()函数中:

```cpp
#ifdef USE_BASE
  case READ_ENCODERS:
    Serial.print(readEncoder(LEFT));
    Serial.print(" ");
    Serial.println(readEncoder(RIGHT));
    break;
   case RESET_ENCODERS:
    resetEncoders();
    resetPID();
    Serial.println("OK");
    break;
  case MOTOR_SPEEDS: //---------------------------------------------
    /* Reset the auto stop timer */
    lastMotorCommand = millis();
    if (arg1 == 0 && arg2 == 0) {
      setMotorSpeeds(0, 0);
      resetPID();
      moving = 0;
    }
    else moving = 1;
    //设置左右电机目标转速分别为参数1和参数2
    leftPID.TargetTicksPerFrame = arg1;
    rightPID.TargetTicksPerFrame = arg2;
    Serial.println("OK"); 
    break;
  case UPDATE_PID:
    while ((str = strtok_r(p, ":", &p)) != '\0') {
       pid_args[i] = atoi(str);
       i++;
    }
    Kp = pid_args[0];
    Kd = pid_args[1];
    Ki = pid_args[2];
    Ko = pid_args[3];
    Serial.println("OK");
    break;
#endif
Copy
```

ROSArduinoBridge.ino 的 loop()函数中:

```cpp
#ifdef USE_BASE
  //如果当前时刻大于 nextPID,那么就执行PID调速，并在 nextPID 上自增一个PID调试周期
  if (millis() > nextPID) {
    updatePID();
    nextPID += PID_INTERVAL;
  }

  // Check to see if we have exceeded the auto-stop interval
  if ((millis() - lastMotorCommand) > AUTO_STOP_INTERVAL) {;
    setMotorSpeeds(0, 0);
    moving = 0;
  }
#endif
Copy
```

diff_controller.h 中的PID调试代码:

```cpp
/* Functions and type-defs for PID control.

   Taken mostly from Mike Ferguson's ArbotiX code which lives at:

   http://vanadium-ros-pkg.googlecode.com/svn/trunk/arbotix/
*/

/* PID setpoint info For a Motor */
typedef struct {
  double TargetTicksPerFrame;    // target speed in ticks per frame 目标转速
  long Encoder;                  // encoder count 编码器计数
  long PrevEnc;                  // last encoder count 上次的编码器计数

  /*
  * Using previous input (PrevInput) instead of PrevError to avoid derivative kick,
  * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/
  */
  int PrevInput;                // last input
  //int PrevErr;                   // last error

  /*
  * Using integrated term (ITerm) instead of integrated error (Ierror),
  * to allow tuning changes,
  * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
  */
  //int Ierror;
  int ITerm;                    //integrated term

  long output;                    // last motor setting
}
SetPointInfo;

SetPointInfo leftPID, rightPID;

/* PID Parameters */
int Kp = 20;
int Kd = 12;
int Ki = 0;
int Ko = 50;

unsigned char moving = 0; // is the base in motion?

/*
* Initialize PID variables to zero to prevent startup spikes
* when turning PID on to start moving
* In particular, assign both Encoder and PrevEnc the current encoder value
* See http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-initialization/
* Note that the assumption here is that PID is only turned on
* when going from stop to moving, that's why we can init everything on zero.
*/
void resetPID(){
   leftPID.TargetTicksPerFrame = 0.0;
   leftPID.Encoder = readEncoder(LEFT);
   leftPID.PrevEnc = leftPID.Encoder;
   leftPID.output = 0;
   leftPID.PrevInput = 0;
   leftPID.ITerm = 0;

   rightPID.TargetTicksPerFrame = 0.0;
   rightPID.Encoder = readEncoder(RIGHT);
   rightPID.PrevEnc = rightPID.Encoder;
   rightPID.output = 0;
   rightPID.PrevInput = 0;
   rightPID.ITerm = 0;
}

/* PID routine to compute the next motor commands */
//左右电机具体调试函数
void doPID(SetPointInfo * p) {
  long Perror;
  long output;
  int input;

  //Perror = p->TargetTicksPerFrame - (p->Encoder - p->PrevEnc);
  input = p->Encoder - p->PrevEnc;
  Perror = p->TargetTicksPerFrame - input;

  //根据 input 绘图
  //Serial.println(input);
  /*
  * Avoid derivative kick and allow tuning changes,
  * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/
  * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
  */
  //output = (Kp * Perror + Kd * (Perror - p->PrevErr) + Ki * p->Ierror) / Ko;
  // p->PrevErr = Perror;
  output = (Kp * Perror - Kd * (input - p->PrevInput) + p->ITerm) / Ko;
  p->PrevEnc = p->Encoder;

  output += p->output;
  // Accumulate Integral error *or* Limit output.
  // Stop accumulating when output saturates
  if (output >= MAX_PWM)
    output = MAX_PWM;
  else if (output <= -MAX_PWM)
    output = -MAX_PWM;
  else
  /*
  * allow turning changes, see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
  */
    p->ITerm += Ki * Perror;

  p->output = output;
  p->PrevInput = input;
}

/* Read the encoder values and call the PID routine */
//PID调试
void updatePID() {
  /* Read the encoders */
  leftPID.Encoder = readEncoder(LEFT);
  rightPID.Encoder = readEncoder(RIGHT);

  /* If we're not moving there is nothing more to do */
  if (!moving){
    /*
    * Reset PIDs once, to prevent startup spikes,
    * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-initialization/
    * PrevInput is considered a good proxy to detect
    * whether reset has already happened
    */
    if (leftPID.PrevInput != 0 || rightPID.PrevInput != 0) resetPID();
    return;
  }

  /* Compute PID update for each motor */
  doPID(&rightPID);
  doPID(&leftPID);

  /* Set the motor speeds accordingly */
  setMotorSpeeds(leftPID.output, rightPID.output);
}
Copy
```

#### 2.PID调试

调试时，需要在 diff_controller.h 中打印 input 的值，然后通过串口绘图器输入命令: m 参数1 参数2，根据绘图结果调试:Kp、Ki和Kd的值。![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/ros_arduino_bridge%E7%9A%84PID%E8%B0%83%E8%AF%95.png)

- 调试时，可以先调试单个电机的PID，比如，可以先注释 doPID(&rightPID)；
- PID算法不同，即便算法相同，如果参与运算的数据单位不同，都会导致不同的调试结果，不可以直接复用之前的调试结果。

PID调试技巧可以参考之前介绍。

#### 3.为两个电机配置不同的PID

1.首先修改arduino代码
a.修改diff_controller.h文件
增加左右两个马达的PID控制变量：

```
 /* PID Parameters */
int Kp = 20;
int Kd = 12;
int Ki = 0;
int Ko = 50;

int left_Kp=Kp;
int left_Kd=Kd;
int left_Ki=Ki;
int left_Ko=Ko;

int right_Kp=Kp;
int right_Kd=Kd;
int right_Ki=Ki;
int right_Ko=Ko;
```

分别定义左右两个马达的dorightPID()和doleftPID()函数

```c
/* PID routine to compute the next motor commands */
void dorightID(SetPointInfo * p) {
  long Perror;
  long output;
  int input;

  //Perror = p->TargetTicksPerFrame - (p->Encoder - p->PrevEnc);
  input = p->Encoder - p->PrevEnc;
  Perror = p->TargetTicksPerFrame - input;

  /*

  * Avoid derivative kick and allow tuning changes,
  * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/
  * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
    */
      //output = (Kp * Perror + Kd * (Perror - p->PrevErr) + Ki * p->Ierror) / Ko;
      // p->PrevErr = Perror;
      output = (right_Kp * Perror - right_Kd * (input - p->PrevInput) + p->ITerm) / right_Ko;
      p->PrevEnc = p->Encoder;

  output += p->output;
  // Accumulate Integral error *or* Limit output.
  // Stop accumulating when output saturates
  if (output >= MAX_PWM)
    output = MAX_PWM;
  else if (output <= -MAX_PWM)
    output = -MAX_PWM;
  else
  /*

  * allow turning changes, see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
    */
    p->ITerm += Ki * Perror;

  p->output = output;
  p->PrevInput = input;
}

/* PID routine to compute the next motor commands */
void doleftPID(SetPointInfo * p) {
  long Perror;
  long output;
  int input;

  //Perror = p->TargetTicksPerFrame - (p->Encoder - p->PrevEnc);
  input = p->Encoder - p->PrevEnc;
  Perror =p->TargetTicksPerFrame - input;

  /*

  * Avoid derivative kick and allow tuning changes,
  * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/
  * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
    */
      //output = (Kp * Perror + Kd * (Perror - p->PrevErr) + Ki * p->Ierror) / Ko;
      // p->PrevErr = Perror;
      output = (left_Kp * Perror - left_Kd * (input - p->PrevInput) + p->ITerm) / left_Ko;
      p->PrevEnc = p->Encoder;

  output += p->output;
  // Accumulate Integral error *or* Limit output.
  // Stop accumulating when output saturates
  if (output >= MAX_PWM)
    output = MAX_PWM;
  else if (output <= -MAX_PWM)
    output = -MAX_PWM;
  else
  /*

  * allow turning changes, see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
    */
    p->ITerm += Ki * Perror;

  p->output = output;
  p->PrevInput = input;
}



```

修改updatePID()函数

```
void updatePID() {
  /* Read the encoders */
  leftPID.Encoder =readEncoder(LEFT);
  rightPID.Encoder = readEncoder(RIGHT);

  /* If we're not moving there is nothing more to do */
  if (!moving){
    /*
    * Reset PIDs once, to prevent startup spikes,
    * see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-initialization/
    * PrevInput is considered a good proxy to detect
    * whether reset has already happened
    */
    if (leftPID.PrevInput != 0 || rightPID.PrevInput != 0) resetPID();
    return;
  }

  /* Compute PID update for each motor */
  dorightID(&rightPID);//执行右马达PID
  doleftPID(&leftPID);//执行左马达PID

  /* Set the motor speeds accordingly */
  setMotorSpeeds(leftPID.output, rightPID.output);

}
```


b.修改ROSArduinoBridge.ino文件
修改argv1 和argv2的数组长度

```
char argv1[32];
char argv2[32];
```

修改pid_args的声明为如下代码

```
int pid_args[8];
```

修改runCommand()函数，修改case UPDATE_PID,把原来的Kp,Kd,Ki,Ko赋值的代码注释掉，修改为如下的代码、



    case UPDATE_PID:
      while ((str = strtok_r(p, ":", &p)) != '\0') {
        pid_args[i] = atoi(str);
        i++;
      }
    //      Kp = pid_args[0];
    //      Kd = pid_args[1];
    //      Ki = pid_args[2];
    //      Ko = pid_args[3];
      left_Kp = pid_args[0];
      left_Kd = pid_args[1];
      left_Ki = pid_args[2];
      left_Ko = pid_args[3];
    
      right_Kp = pid_args[4];
      right_Kd = pid_args[5];
      right_Ki = pid_args[6];
      right_Ko = pid_args[7];
      Serial.println("OK");
      break;


现在arduino端已经支持对两个电机使用不同的PID参数调速了

2.修改上位机ROS包的代码
a.修改my_arduino_params.yaml
在PID参数部分增加左右两个马达的PID参数

```
=== PID parameters
Kp: 10
Kd: 12
Ki: 0
Ko: 50
accel_limit: 1.0

left_Kp: 10
left_Kd: 12
left_Ki: 0
left_Ko: 50

right_Kp: 8
right_Kd: 12
right_Ki: 0
right_Ko: 50
```

b.修改arduino_driver.py文件
修改update_pid()函数

```c
def update_pid(self, left_Kp, left_Kd, left_Ki, left_Ko, right_Kp, right_Kd, right_Ki, right_Ko):
        ''' Set the PID parameters on the Arduino
        '''
        print "Updating PID parameters"
        cmd = 'u ' + str(left_Kp) + ':' + str(left_Kd) + ':' + str(left_Ki) + ':' + str(left_Ko) + ':' + str(right_Kp) + ':' + str(right_Kd) + ':' + str(right_Ki) + ':' + str(right_Ko)
        self.execute_ack(cmd)  
```



c.修改base_controller.py文件
修改def init(self, arduino, base_frame):函数，增加左右两个马达PID参数的初始化代码

    def __init__(self, arduino, base_frame):
        self.arduino = arduino
        self.base_frame = base_frame
        self.rate = float(rospy.get_param("~base_controller_rate", 10))
        self.timeout = rospy.get_param("~base_controller_timeout", 1.0)
        self.stopped = False
        pid_params = dict()
        pid_params['wheel_diameter'] = rospy.get_param("~wheel_diameter", "") 
        pid_params['wheel_track'] = rospy.get_param("~wheel_track", "")
        pid_params['encoder_resolution'] = rospy.get_param("~encoder_resolution", "") 
        pid_params['gear_reduction'] = rospy.get_param("~gear_reduction", 1.0)
    
        pid_params['left_Kp'] = rospy.get_param("~left_Kp", 20)
        pid_params['left_Kd'] = rospy.get_param("~left_Kd", 12)
        pid_params['left_Ki'] = rospy.get_param("~left_Ki", 0)
        pid_params['left_Ko'] = rospy.get_param("~left_Ko", 50)
        pid_params['right_Kp'] = rospy.get_param("~right_Kp", 20)
        pid_params['right_Kd'] = rospy.get_param("~right_Kd", 12)
        pid_params['right_Ki'] = rospy.get_param("~right_Ki", 0)
        pid_params['right_Ko'] = rospy.get_param("~right_Ko", 50)
    
        self.accel_limit = rospy.get_param('~accel_limit', 0.1)
        self.motors_reversed = rospy.get_param("~motors_reversed", False)
    
        # Set up PID parameters and check for missing values
        self.setup_pid(pid_params)
    
        # How many encoder ticks are there per meter?
        self.ticks_per_meter = self.encoder_resolution * self.gear_reduction  / (self.wheel_diameter * pi)
    
        # What is the maximum acceleration we will tolerate when changing wheel speeds?
        self.max_accel = self.accel_limit * self.ticks_per_meter / self.rate
    
        # Track how often we get a bad encoder count (if any)
        self.bad_encoder_count = 0
    
        now = rospy.Time.now()    
        self.then = now # time for determining dx/dy
        self.t_delta = rospy.Duration(1.0 / self.rate)
        self.t_next = now + self.t_delta
    
        # internal data        
        self.enc_left = None            # encoder readings
        self.enc_right = None
        self.x = 0                      # position in xy plane
        self.y = 0
        self.th = 0                     # rotation in radians
        self.v_left = 0
        self.v_right = 0
        self.v_des_left = 0             # cmd_vel setpoint
        self.v_des_right = 0
        self.last_cmd_vel = now
    
        # subscriptions
        rospy.Subscriber("cmd_vel", Twist, self.cmdVelCallback)
    
        # Clear any old odometry info
        self.arduino.reset_encoders()
    
        # Set up the odometry broadcaster
        self.odomPub = rospy.Publisher('odom', Odometry)
        self.odomBroadcaster = TransformBroadcaster()
    
        rospy.loginfo("Started base controller for a base of " + str(self.wheel_track) + "m wide with " + str(self.encoder_resolution) + " ticks per rev")
        rospy.loginfo("Publishing odometry data at: " + str(self.rate) + " Hz using " + str(self.base_frame) + " as base frame")

修改def setup_pid(self, pid_params):

    def setup_pid(self, pid_params):
        # Check to see if any PID parameters are missing
        missing_params = False
        for param in pid_params:
        if pid_params[param] == "":
        print("*** PID Parameter " + param + " is missing. ***")
        missing_params = True
        if missing_params:
            os._exit(1)
    
        self.wheel_diameter = pid_params['wheel_diameter']
        self.wheel_track = pid_params['wheel_track']
        self.encoder_resolution = pid_params['encoder_resolution']
        self.gear_reduction = pid_params['gear_reduction']
    
        #self.Kp = pid_params['Kp']
        #self.Kd = pid_params['Kd']
        #self.Ki = pid_params['Ki']
        #self.Ko = pid_params['Ko']
    
        #self.arduino.update_pid(self.Kp, self.Kd, self.Ki, self.Ko)
    
        #modify by william
        self.left_Kp = pid_params['left_Kp']
        self.left_Kd = pid_params['left_Kd']
        self.left_Ki = pid_params['left_Ki']
        self.left_Ko = pid_params['left_Ko']
    
        self.right_Kp = pid_params['right_Kp']
        self.right_Kd = pid_params['right_Kd']
        self.right_Ki = pid_params['right_Ki']
        self.right_Ko = pid_params['right_Ko']
        self.arduino.update_pid(self.left_Kp, self.left_Kd, self.left_Ki, self.left_Ko, self.right_Kp, self.right_Kd, self.right_Ki, self.right_Ko)


​       修改完上述代码后ros_arduino_bridge可以分别对两个马达设置不同的PID参数进行调速。

## 8.5 机器人平台设计之控制系统

我们机器人平台的控制系统应该如何设计？ROS系统的控制系统选择是多样的，一般常用的有基于ARM、x86等架构的处理器，比如:PC、工控机、树莓派...，不同的处理器都存在一定的优缺点，PC和工控机，处理器性能强大，但是功耗高、体积大、灵活性差。嵌入式系统则反之。

> 那么应该如何选择控制系统呢?
>
> 比如:如果是中大型机器人，可以使用PC或工控机等作为控制系统;但是如果是小型或微型机器人，就应该使用嵌入式系统吗？
>
> 我们机器人平台属于小型甚至微型机器人，虽然也可以使用PC作为机器人的控制系统，不过无论是从尺寸、负载能力还是扩展性的角度来看显然都是不适宜的。但是如果只是将控制系统简单小型化，比如使用树莓派，处理复杂的算法或比较耗资源的仿真实现显然又不能满足算力的要求...当前情形好像陷入了两难的境地。

**ROS是一种分布式设计框架，针对小型或微型机器人平台的控制系统，可以选择多处理器的实现策略。**具体实现是“PC + 嵌入式”，可以使用嵌入式系统(比如树莓派)充当机器人本体的控制系统，而PC则实现远程监控，通过前者实现数据采集与直接的底盘控制，而后者则远程实现图形显示以及功能运算。本节就主要介绍的就是这种多处理器的组合式框架实现，具体内容如下:

- 树莓派概述；
- 实现树莓派与PC的分布式系统搭建；
- 使用 ssh 远程连接树莓派；
- 树莓派端安装并配置 ros_arduino_bridge。

### 8.5.1 控制系统实现_树莓派概述

#### 概念

Raspberry Pi(中文名为“树莓派”,简写为RPi，(或者RasPi / RPI)是为学习计算机编程教育而设计)，**只有信用卡大小的微型电脑，其系统基于Linux。**随着Windows 10 IoT的发布，我们也将可以用上运行Windows的树莓派。

#### 结构

它是一款**基于ARM 的微型电脑主板**，以SD/MicroSD卡为内存硬盘，卡片主板周围有1/2/4个USB接口和一个以太网接口（A型没有网口），可连接键盘、鼠标和网线，同时拥有视频模拟信号的电视输出接口和HDMI高清视频输出接口，以上部件全部整合在一张仅比信用卡稍大的主板上，**具备所有PC的基本功能**只需接通电视机和键盘，就能执行如电子表格、文字处理、玩游戏、播放高清视频等诸多功能，下图为树莓派4b。

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%A0%91%E8%8E%93%E6%B4%BE4b_.jpg)

#### 配件

单独一块树莓派主板是无法运行的，必须集成一些配件才能实现一定的功能，树莓派周边配件是比较丰富的，比如：USB电源、SD卡、读卡器、HDMI连接线、显示屏、键盘、鼠标、保护壳、风扇等等，除此之外还有各式各样的传感器:声音传感器、温度传感器、土壤湿度传感器....对于我们教程而言，所需的配件比较简单，硬件清单如下:

- 树莓派主板
- 电源线
- SD卡(已安装 Ubuntu 以及 ROS)
- 显示屏或 HDMI采集卡以及配套的数据线
- 鼠标、键盘

#### 接线以及使用

1.树莓派连接显示屏

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%98%BE%E7%A4%BA%E5%99%A8.jpg)

2.树莓派连接HDMI采集卡

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%BF%9E%E6%8E%A5HDMI.jpg)

使用 windows 的相机查看运行结果，打开windows相机并点击更改相机即可:

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E7%9B%B8%E6%9C%BA%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE.PNG)

### 8.5.2 控制系统实现_分布式框架

当前分布式框架搭建时，树莓派是作为主机，而PC则作为从机，关于分布式框架的搭建流程，我们在第4章4.7节中已有详细介绍，按照流程实现即可，不过在实现此流程前，还需要做准备工作：为树莓派连接无线网络，并设置固定IP，实现如下：

1.硬件准备：使用显示屏或 HDMI采集卡连接树莓派并启动；

2.为树莓派连接无线网络；

3.为树莓派配置静态IP，具体操作如图：

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/wifi%E8%AE%BE%E7%BD%AE.png)![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/wifi%E8%AE%BE%E7%BD%AE2.png)

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/wifi%E8%AE%BE%E7%BD%AE3.png)

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/wifi%E8%AE%BE%E7%BD%AE4.png)

固定IP配置完毕后，按照4.7节演示，配置分布式框架即可。

### 8.5.3 控制系统实现_ssh远程连接

在多处理器的分布式架构中，不同的ROS系统之间可能会频繁的涉及到文件的传输，比如:

> 我们在PC端编写ROS程序，而最终需要在树莓派上运行，如何将相关目录以及文件从PC上传到树莓派？

SSH 是常用手段之一。

------

#### 概念

SSH（Secure Shell）是一种通用的、功能强大的、基于软件的网络安全解决方案。计算机每次向网络发送数据时，SSH都会自动对其进行加密。数据到达目的地时，SSH自动对加密数据进行解密。整个过程都是透明的，使用OpenSSH工具将会增进你的系统安全性。SSH安装容易、使用简单。

#### 实现

SSH实现架构上分为客户端和服务器端两大部分，客户端是数据的发送方，服务端是数据的接收方，当前场景下，我们需要从PC端发送数据到树莓派，那么PC端属于客户端，而树莓派属于服务端，整个实现具体流程是:

1. 分别安装SSH客户端与服务端
2. 服务端启动SSH服务
3. 客户端远程登陆服务端
4. 实现数据传输

##### 1.安装SSH客户端与服务端

默认情况下，Ubuntu系统已经安装了SSH客户端，因此只需要在树莓派安装服务端即可(如果树莓派安装的是服务版的Ubuntu，默认会安装SSH服务并已设置成了开机自启动):

```
 sudo apt-get install openssh-server
Copy
```

如果客户端需要自行安装，那么调用如下命令:

```
sudo apt-get install openssh-client
Copy
```

##### 2.服务端启动SSH服务

树莓派启动 ssh 服务:

```
sudo /etc/init.d/ssh start
Copy
```

启动后查看服务是否正常运行:

```
ps -e | grep ssh
Copy
```

如果启动成功，会包含 sshd 与 ssh 两个程序。

以后需要频繁的使用ssh登录树莓派，为了简化实现，可以将树莓派的ssh服务设置为开机自启动，命令如下:

```
sudo systemctl enable ssh
Copy
```

##### 3.客户端远程登陆服务端

登陆树莓派可以调用如下命令:

```
ssh 账号@ip地址
Copy
```

然后根据提示，录入登陆密码，即可成功登陆。

如果退出登陆，可以调用exit命令:

```
exit
Copy
```

##### 4.实现数据传输

上传文件:

```
scp 本地文件路径 账号@ip:树莓派路径
Copy
```

上传文件夹:

```
scp -r 本地文件夹路径 账号@ip:树莓派路径
Copy
```

下载文件:

```
scp 账号@ip:树莓派路径 本地文件夹路径
Copy
```

下载文件夹:

```
scp -r 账号@ip:树莓派路径 本地文件夹路径
Copy
```

#### 使用优化

每次登陆树莓派时，都需要输入密码，使用不方便，可以借助密钥简化登陆过程，实现免密登陆，提高操作效率，实现思想是:生成一对公钥私钥，私钥存储在本地，公钥上传至服务器，每次登陆时，本地直接上传私钥到服务器，服务器有匹配的公钥就认为是合法用户，直接创建SSH连接即可。具体实现步骤只有两步:

1. 本地生成密钥对
2. 将公钥上传至树莓派

##### 1.生成密钥对

本地客户端生成公私钥：（一路回车默认即可）

```
ssh-keygen
Copy
```

上面这个命令会在用户目录.ssh文件夹下创建公私钥:

1. id_rsa （私钥）
2. id_rsa.pub (公钥)

##### 2.将公钥上传至树莓派

上传命令:

```
ssh-copy-id -i ~/.ssh/id_rsa.pub 账号@ip
Copy
```

上面这条命令是写到服务器上的ssh目录下，该目录下有文件authorized_keys保存了公钥内容。

以后再登陆树莓派就无需录入密码了。

### 8.5.4 控制系统实现_安装ros_arduino_bridge

如果你已经搭建并测试通过了分布式环境，下一步，就可以将ros_arduino_bridge功能包上传至树莓派，并在PC端通过键盘控制小车的运动了，实现流程如下:

1. 系统准备；
2. 程序修改；
3. 从PC端上传程序至树莓派；
4. 分别启动PC与树莓派端相关节点，并实现运动控制。

#### 1.系统准备

ros_arduino_bridge是依赖于python-serial功能包的，请先在树莓派端安装该功能包，安装命令:

```
$ sudo apt-get install python-serial

```

或

```
$ sudo pip install --upgrade pyserial
```

或

```
$ sudo easy_install -U pyserial
```

#### 2.程序修改

ros_arduino_bridge的ROS端功能包主要是使用 ros_arduino_python，程序入口是该包launch目录下的arduino.launch文件，内容如下:

```xml
<launch>
   <node name="arduino" pkg="ros_arduino_python" type="arduino_node.py" output="screen">
      <rosparam file="$(find ros_arduino_python)/config/my_arduino_params.yaml" command="load" />
   </node>
</launch>
Copy
```

需要载入yaml格式的配置文件，该文件在 config 目录下已经提供了模板，只需要复制文件并按需配置即可，复制文件并重命名，配置如下：

```yaml
# For a direct USB cable connection, the port name is typically
# /dev/ttyACM# where is # is a number such as 0, 1, 2, etc
# For a wireless connection like XBee, the port is typically
# /dev/ttyUSB# where # is a number such as 0, 1, 2, etc.

port: /dev/ttyACM0 #视情况设置，一般设置为 /dev/ttyACM0 或 /dev/ttyUSB0
baud: 57600 #波特率
timeout: 0.1 #超时时间

rate: 50
sensorstate_rate: 10

use_base_controller: True  #启用基座控制器
base_controller_rate: 10   

# For a robot that uses base_footprint, change base_frame to base_footprint
base_frame: base_footprint #base_frame 设置

# === Robot drivetrain parameters
wheel_diameter: 0.065 #车轮直径
wheel_track: 0.21 #轮间距
encoder_resolution: 3960#编码器精度(一圈的脉冲数 * 倍频 * 减速比)
#gear_reduction: 1 #减速比
#motors_reversed: False #转向取反

# === PID parameters PID参数，需要自己调节
Kp: 5
Kd: 45
Ki: 0
Ko: 50
accel_limit: 1.0

# === Sensor definitions.  Examples only - edit for your robot.
#     Sensor type can be one of the follow (case sensitive!):
#      * Ping
#      * GP2D12
#      * Analog
#      * Digital
#      * PololuMotorCurrent
#      * PhidgetsVoltage
#      * PhidgetsCurrent (20 Amp, DC)



sensors: {
  #motor_current_left:   {pin: 0, type: PololuMotorCurrent, rate: 5},
  #motor_current_right:  {pin: 1, type: PololuMotorCurrent, rate: 5},
  #ir_front_center:      {pin: 2, type: GP2D12, rate: 10},
  #sonar_front_center:   {pin: 5, type: Ping, rate: 10},
  arduino_led:          {pin: 13, type: Digital, rate: 5, direction: output}
}
```

#### 3.程序上传

请先在树莓派端创建工作空间，在PC端进入本地工作空间的src目录，调用程序上传命令:

```
scp -r ros_arduino_bridge/ 树莓派用户名@树莓派ip:~/工作空间/src
```

在树莓派端进入工作空间并编译:

```
catkin_make
```

#### 4.测试

现启动树莓派端程序，再启动PC端程序。

**树莓派端**

启动 ros_arduino_bridge 节点:

```
roslaunch ros_arduino_python arduino.launch
```

**PC端**

启动键盘控制节点：

```
rosrun teleop_twist_keyboard teleop_twist_keyboard.py
```

如无异常，现在就可以在PC端通过键盘控制小车运动了，并且PC端还可以使用rviz查看小车的里程计信息。

### 资料:控制系统实现_树莓派安装ROS

在树莓派上搭建ROS环境需要两步实现:

1. 在树莓派上安装Ubuntu
2. 基于Ubuntu安装ROS

版本选择:

- Ubuntu选用18.04
- ROS选用melodic
- 树莓派选用4b

具体实现流程如下。

#### 1.Ubuntu安装

##### 1.1硬件准备

- 树莓派
- 读卡器
- TF卡(建议16G以及以上)
- 显示屏或 HDMI采集卡 以及配套的数据线
- 鼠标键盘
- 网线

##### 1.2软件准备

1.Ubuntu18.04下载并解压，下载地址:[https://ubuntu-mate.org/download/](https://ubuntu.com/download/raspberry-pi)

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/ubuntu%E9%95%9C%E5%83%8F.png)![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/ubuntu%E4%B8%8B%E8%BD%BD.png)

2.win32 Disk Imager烧录软件下载并安装，下载地址:https://sourceforge.net/projects/win32diskimager/

根据提示下载并安装

3.如果TF卡已有内容，在使用之前需要执行格式化，比如可以使用SD Card Formatter:

SD Card Formatter下载并安装，下载地址:https://www.sdcard.org/downloads/formatter/

##### 1.3系统烧录

1.将TF卡插入读卡器，读卡器插入计算机；

2.如果TF卡已有内容，请先格式化(如无数据，此步骤略过)；

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%A0%BC%E5%BC%8F%E5%8C%96.png)

3.启动win32 Disk Imager，选择先行下载的Ubuntu18.04镜像并写入TF卡；

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85Ubuntu%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95.PNG)

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85Ubuntu%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95%E6%88%90%E5%8A%9F.PNG)

##### 1.4系统安装

1.系统启动以及登录

取下TF卡插入树莓派，**连接网线**，启动树莓派，启动时是命令行界面，登陆使用默认账号密码，

默认账号:ubuntu

默认密码:ubuntu

还需要根据提示修改密码。

更改密码后，系统安装完毕，不过此时是命令行式操作，下一步需要安装桌面。

2.桌面安装

为了安装方便，建议使用ssh远程登录(需要先安装ssh，可以参考:8.5.3)

首先，调用命令: ifconfig 获取树莓派的 ip 地址；

然后，远程调用 ssh ubuntu@ip地址登录；

接下来，可以直接安装桌面，但是为了提高安装效率，建议更换下载源，使用国内资源:

阿里云源

```
deb https://mirrors.aliyun.com/ubuntu-ports/ disco main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu-ports/ disco main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu-ports/ disco-security main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu-ports/ disco-security main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu-ports/ disco-updates main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu-ports/ disco-updates main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu-ports/ disco-backports main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu-ports/ disco-backports main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu-ports/ disco-proposed main restricted universe multiverse
deb-src https://mirrors.aliyun.com/ubuntu-ports/ disco-proposed main restricted universe multiverse
Copy
```

中科大源

```
deb https://mirrors.ustc.edu.cn/ubuntu-ports/ disco main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ disco main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu-ports/ disco-updates main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ disco-updates main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu-ports/ disco-backports main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ disco-backports main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu-ports/ disco-security main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ disco-security main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu-ports/ disco-proposed main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ disco-proposed main restricted universe multiverse
Copy
```

清华源

```
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco-updates main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco-backports main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco-security main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco-security main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco-proposed main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ disco-proposed main restricted universe multiverse
Copy
```

修改/etc/apt/sources.list文件，将上述资源的任意一个复制进文件。

```
sudo nano /etc/apt/sources.list
Copy
```

最后，安装桌面环境（可选择：xubuntu-desktop、lubuntu-desktop、kubuntu-desktop）

```
sudo apt-get install ubuntu-desktop
Copy
```

3.重启桌面安装完毕

4.同步时间

默认情况下，树莓派系统时间是格林威治时间，而我们处于东八区，相差八个小时，需要将时间，设置为北京时间。

在/etc/profile文件中增加一行**export TZ='CST-8'** ，并使文件立即生效，执行命令:

**source /etc/profile**或者**. /etc/profile**。

#### 方式二

1.树莓派镜像烧录器
下载地址：https://www.raspberrypi.com/software/

![image-20231108155217695](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231108155217695.png)

2.下载Ubuntu18.04镜像

清华镜像网址：https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu/releases/18.04/release/

![image-20231108161802863](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231108161802863.png)

3.系统烧录

3.1烧录前格式化TF卡

![image-20231108161943534](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231108161943534.png)

3.2开始烧录

![image-20231108162505176](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231108162505176.png)

![image-20231108162720285](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231108162720285.png)

![image-20231108162745202](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231108162745202.png)

![image-20231108162814414](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231108162814414.png)

3.3烧录完成后将TF卡插入树莓派

4.开机后报错![3edf3719e947845c81144d4c198006c](C:\Users\why\Documents\WeChat Files\wxid_a3tf1cq3jo7822\FileStorage\Temp\3edf3719e947845c81144d4c198006c.jpg)

此时可以前往如下网址，下载最新[固件](https://so.csdn.net/so/search?q=固件&spm=1001.2101.3001.7020)包。

> ```
> https://github.com/raspberrypi/rpi-firmware
> ```

![image-20231108172136532](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231108172136532.png)

用固件包中的这八个文件替换TF卡中的这些文件

5.使用鱼香ROS更换系统源

https://fishros.com/docs/page/#/tools/install-ros/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90ROS

6.完成后执行更新

```
sudo apt update
sudo apt upgrade
```

6.1 过程中报错

dpkg: error processing package flash-kernel (--configure):
 installed flash-kernel package post-installation script subprocess returned error exit status 1
Errors were encountered while processing:
 flash-kernel

执行以下命令

```
FLASH_KERNEL_SKIP=1 dpkg --configure flash-kernel
sudo apt-get purge flash-kernel
```

7.安装图形桌面

```
sudo apt install ubuntu-desktop
```

8.树莓派开机后wifi列表为空的解决方法
出现该问题的原因：50-cloud-init.yaml文件根据烧录时network-config中的配置，自动生成了wifi相关信息描述，导致wifi列表不能显示。
解决方案：执行以下代码：

```
sudo lshw
cd /etc/netplan
sudo nano 50-cloud-init.yaml
```

将wifi信息相关代码注释掉
![image-20231108180838571](C:\Users\why\AppData\Roaming\Typora\typora-user-images\image-20231108180838571.png)

保存后按`ctrl + x`退出后重启即可。

9.远程连接树莓派桌面

Xrdp 在默认的 Ubuntu 软件源中可用。想要安装它， 运行：

```
sudo apt install xrdp
```

当你的安装过程结束时，Xrdp 服务将会自动启动。你可以通过运行下面的命令验证 Xrdp 是否正在运行：

```
sudo systemctl status xrdp
```

输出将会像下面这样：

```
● xrdp.service - xrdp daemon
   Loaded: loaded (/lib/systemd/system/xrdp.service; enabled; vendor preset: enabled)
   Active: active (running) since Sun 2019-07-28 22:40:53 UTC; 4min 21s ago
     Docs: man:xrdp(8)
           man:xrdp.ini(5)
  ...
```

默认情况下，Xrdp 使用`/etc/ssl/private/ssl-cert-snakeoil.key`文件对于『ssl-cert』用户组成员可读。执行下面的命令将`xrdp`用户添加到这个用户组：

```
sudo adduser xrdp ssl-cert
```

就这样。Xrdp 已经在你的 Ubuntu 服务器上安装好了。

#### 2.ROS安装

在树莓派上安装ROS与PC上安装流程类似:

##### 1.配置软件与更新

首先打开“软件和更新”对话框，具体可以在 Ubuntu 搜索按钮中搜索。打开并配置（确保勾选了"restricted"， "universe，" 和 "multiverse."），可参考PC实现。

##### 2.设置安装源

官方默认安装源:

```
sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'
Copy
```

或来自国内中科大的安装源

```
sudo sh -c '. /etc/lsb-release && echo "deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main" > /etc/apt/sources.list.d/ros-latest.list'
Copy
```

或来自国内清华的安装源

```
sudo sh -c '. /etc/lsb-release && echo "deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main" > /etc/apt/sources.list.d/ros-latest.list'
Copy
```

PS:回车后,可能需要输入管理员密码

##### 3.设置key

```
sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654
Copy
```

##### 4.安装

首先需要更新 apt(以前是 apt-get, 官方建议使用 apt 而非 apt-get),apt 是用于从互联网仓库搜索、安装、升级、卸载软件或操作系统的工具。

```
sudo apt update
Copy
```

等待...

然后，再安装所需类型的 ROS:ROS 多个类型:**Desktop-Full**、**Desktop**、**ROS-Base**。由于在分布式架构中，树莓派担当角色较为简单，在此选择 Desktop 或 ROS-Base 安装

```
sudo apt install ros-melodic-desktop
Copy
```

##### 5.环境配置

配置环境变量，方便在任意 终端中使用 ROS。

```
echo "source /opt/ros/melodic/setup.bash" >> ~/.bashrc
source ~/.bashrc
Copy
```

##### 6.构建软件包的依赖关系

到目前为止，已经安装了运行核心ROS软件包所需的软件。要创建和管理您自己的ROS工作区，还需要安装其他常用依赖:

```
sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential
Copy
```

安装并初始化rosdep，在使用许多ROS工具之前，需要初始化rosdep。rosdep使您可以轻松地为要编译的源安装系统依赖:

```
sudo apt install python-rosdep
Copy
```

使用以下命令，可以初始化rosdep。

```
sudo rosdep init
rosdep update
```

## 8.6 机器人平台设计之传感器

当前机器人平台使用的传感器主要有三种:编码器、激光雷达与相机。编码器主要用于测速实现，在之前已有详细介绍，不再赘述，本节主要介绍激光雷达与相机的使用。

### 8.6.1 传感器_激光雷达简介

激光雷达是现今机器人尤其是无人车领域及最重要、最关键也是最常见的传感器之一，是机器人感知外界的一种重要手段。

#### 概念

激光雷达(LiDAR)，英文全称为:Light Detection And Ranging，即光探测与测量。

#### 原理

激光雷达可以发射激光束，光束照射到物体上，再反射回激光雷达，可以通过三角法测距或TOF测距计算出激光雷达与物体的距离。甚至也可以通过测量反射回来的信号中的某些特性而确定物体特征，比如:物体的材质。

注意:如果物体表面光滑(比如镜子)，光束照射后产生镜面反射，可能无法捕获返回的激光而出现识别失误的情况。

#### 优点

激光雷达在测距方面精准(激光雷达的测量精度可达厘米级)、高效，是机器人测距的不二之选。

- **具有极高的分辨率:**激光雷达工作于光学波段，频率比微波高2～3个数量级以上，因此，与微波雷达相比，激光雷达具有极高的距离分辨率、角分辨率和速度分辨率；
- **抗干扰能力强:**激光波长短，可发射发散角非常小（μrad量级）的激光束，多路径效应小（不会形成定向发射与微波或者毫米波产生多路径效应），可探测低空/超低空目标；
- **获取的信息量丰富:**可直接获取目标的距离、角度、反射强度、速度等信息，生成目标多维度图像；
- **可全天时工作:**激光主动探测，不依赖于外界光照条件或目标本身的辐射特性。它只需发射自己的激光束，通过探测发射激光束的回波信号来获取目标信息。

#### 缺点

激光雷达虽然优点多多，但也存在一些局限性:

- **成本:**居高不下
- **环境**:易受天气影响(大雾、雨天、烟尘)
- **属性识别能力弱:**激光雷达的点云数据是物体的几何外形呈现，无法如同人类视觉一样，分辨物体的物理特征，比如:颜色、纹理...

#### 分类

根据线束数量的多少，激光雷达可分为单线束激光雷达与多线束(4线、8线、16线、32线、64线)激光雷达。单线激光雷达扫描一次只产生一条扫描线， 其所获得的数据为2D数据，因此无法区别有关目标物体的3D信息。多线束激光雷达就是将多个横向扫描结果纵向叠加，从而获得3D数据，当然，线束越多，纵向的垂直视野角度越大。

### 8.6.2 传感器_雷达使用

思岚A1激光雷达(下图)是一款性价比较高的单线激光雷达。

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%80%9D%E5%B2%9AA1%28%E6%96%B0%E6%AC%BE%29.jpg)

使用流程如下:

1. 硬件准备；
2. 软件安装；
3. 启动并测试。

#### 1.硬件准备

##### 1.雷达连接上位机

当前直接连接树莓派即可，如果连接的是虚拟机，注意VirtualBox或VMware的相关设置。

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/VBox%E6%B7%BB%E5%8A%A0%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE.PNG)

##### 2.确认当前的 USB 转串口终端并修改权限

USB查看命令:

```
ll /dev/ttyUSB*
```

授权(将当前用户添加进dialout组，与arduino类似):

```
sudo usermod -a -G dialout your_user_name
```

不要忘记重启，重启之后才可以生效。

#### 2.软件安装

进入工作空间的src目录，下载相关雷达驱动包，下载命令如下:

```
git clone https://github.com/slamtec/rplidar_ros
```

返回工作空间，调用`catkin_make`编译，并`source ./devel/setup.bash`，为端口设置别名(将端口 ttyUSBX 映射到 rplidar):

```
cd src/rplidar_ros/scripts/
./create_udev_rules.sh
```

#### 3.启动并测试程度

##### 1.rplidar.launch文件准备

首先确认端口,编辑 rplidar.launch 文件

```xml
<launch>
  <node name="rplidarNode"          pkg="rplidar_ros"  type="rplidarNode" output="screen">
  <param name="serial_port"         type="string" value="/dev/rplidar"/>
  <param name="serial_baudrate"     type="int"    value="115200"/><!--A1/A2 -->
  <!--param name="serial_baudrate"     type="int"    value="256000"--><!--A3 -->
  <param name="frame_id"            type="string" value="laser"/>
  <param name="inverted"            type="bool"   value="false"/>
  <param name="angle_compensate"    type="bool"   value="true"/>
  </node>
</launch>
Copy
```

frame_id 也可以修改，当使用URDF显示机器人模型时，需要与 URDF 中雷达 id 一致

##### 2.终端中执行 launch 文件

终端工作空间下输入命令:

```
roslaunch rplidar_ros rplidar.launch
```

如果异常，雷达开始旋转

##### 3.rviz中订阅雷达相关消息

启动 rviz，添加 LaserScan 插件：

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%80%9D%E5%B2%9AA1%E9%9B%B7%E8%BE%BE%E6%98%BE%E7%A4%BA.PNG)

注意: Fixed Frame 设置需要参考 rplidar.launch 中设置的 frame_id，Topic 一般设置为 /scan，Size 可以自由调整。

### 8.6.3 传感器_相机简介

相机是机器人系统中另一比较重要的传感器，与雷达类似的，相机也是机器人感知外界环境的重要手段之一，并且随着机器视觉、无人驾驶等技术的兴起，相机在物体识别、行为识别、SLAM中等都有着广泛的应用。

根据工作原理的差异可以将相机大致划分成三类:单目相机、双目相机与深度相机。

#### 1.单目相机

单目相机是将三维世界二维化，它是将拍摄场景在相机的成像平面上留下一个投影，静止状态下是无法通过单目相机确定深度信息。向如下动图展示的一样，在二维图形中，甚至不能根据图片中物体的大小来判断物体距离。

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E.gif)

#### 2.双目相机

识破上面的“骗局”只需要移动单目相机，再换一个角度拍摄一张照片即可，当角度切换后，可以将两张照片组合还原为一个立体的三维世界。

双目相机的原理也是如此，双目相机是由两个单目相机组成的，即便在静止状态下，也可以生成两张图片，两个单目相机之间存在一定的距离也称之为基线，通过这个基线以及两个单目项目分别生成的图片，可以来估算每个象素的空间位置。

#### 3.深度相机

深度相机也称之为RGB-D相机，顾名思义，深度相机也可以用于获取物体深度信息。深度相机一般基于结构光或ToF(Time-of-Flight)原理实现测距。

前者是通过近红外激光器，将具有一定结构特征的光线投射到被拍摄物体上，再由专门的红外摄像头进行采集。光线照射到不同深度的物体上时，会采集到不同的图像相位信息，然后通过运算单元将这种结构的变化换算成深度信息，后者实现则类似于激光雷达，也是根据光线的往返时间来计算深度信息。

### 8.6.4 传感器_相机使用

使用流程如下:

1. 硬件准备；
2. 软件安装；
3. 启动并测试。

#### 1.硬件准备

当前直接连接树莓派即可，如果连接的是虚拟机，注意VirtualBox或VMware的相关设置。

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%91%84%E5%83%8F%E5%A4%B4%E9%85%8D%E7%BD%AE.PNG)

#### 2.软件准备

安装USB摄像头软件包，命令如下:

```
sudo apt-get install ros-ROS版本-usb-cam
Copy
```

或者也可以从 github 直接下载源码:

```
git clone https://github.com/ros-drivers/usb_cam.git
Copy
```

#### 3.测试

##### 1.launch文件准备

在软件包中内置了测试用的launch文件，内容如下:

```xml
<launch>
  <node name="usb_cam" pkg="usb_cam" type="usb_cam_node" output="screen" >
    <param name="video_device" value="/dev/video0" />
    <param name="image_width" value="640" />
    <param name="image_height" value="480" />
    <param name="pixel_format" value="yuyv" />
    <param name="camera_frame_id" value="usb_cam" />
    <param name="io_method" value="mmap"/>
  </node>
  <node name="image_view" pkg="image_view" type="image_view" respawn="false" output="screen">
    <remap from="image" to="/usb_cam/image_raw"/>
    <param name="autosize" value="true" />
  </node>
</launch>
```

节点 usb_cam 用于启动相机，节点 image_view 以图形化窗口的方式显示图像数据，需要查看相机的端口并修改 usb_cam 中的 video_device 参数，并且如果将摄像头连接到了树莓派，且通过 ssh 远程访问树莓派的话，需要注释 image_view 节点，因为在终端中无法显示图形化界面。

##### 2.启动launch文件

```
roslaunch usb_cam usb_cam-test.launch
```

##### 3.rviz显示

启动 rviz，添加 LaserScan 插件：

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E7%9B%B8%E6%9C%BA%E6%98%BE%E7%A4%BA.PNG)

------

[
  ](http://www.autolabor.com.cn/book/ROSTutorials/di-8-zhang-gou-jian-lun-shi-cha-fen-ji-qi-ren/81-gai-shu/88-ji-qi-ren-ping-tai-she-ji-zhi-chuan-gan-qi/885-chuan-gan-qi-zu-zhuang.html)

### 8.6.5 传感器_集成

之前已经分别介绍了底盘、雷达、相机等相关节点的安装、配置以及使用，不过之前的实现还存在一些问题:

> 1.机器人启动时，需要逐一启动底盘控制、相机与激光雷达，操作冗余；
>
> 2.如果只是简单的启动这些节点，那么在 rviz 中显示时，会发现出现了TF转换异常，比如参考坐标系设置为odom时，雷达信息显示失败。

本节将介绍如何把传感器(激光雷达与相机)集成以解决上述问题，所谓集成主要是优化底盘、雷达、相机相关节点的启动并通过坐标变换实现机器人底盘与里程计、雷达和相机的关联，实现步骤如下:

1. 编写用于集成的 launch 文件；
2. 发布TF坐标变换；
3. 启动并测试。

#### 1.launch文件

新建功能包:

```
catkin_create_pkg mycar_start roscpp rospy std_msgs ros_arduino_python usb_cam rplidar_ros
# 无相机
catkin_create_pkg mycar_start roscpp rospy std_msgs ros_arduino_python rplidar_ros
```

功能包下创建launch文件夹，launch文件夹中新建launch文件，文件名自定义。

内容如下:

```xml
<!-- 机器人启动文件：
        1.启动底盘
        2.启动激光雷达
        3.启动摄像头
 -->
<launch>
        <include file="$(find ros_arduino_python)/launch/arduino.launch" />
        <include file="$(find usb_cam)/launch/usb_cam-test.launch" />
        <include file="$(find rplidar_ros)/launch/rplidar.launch" />
</launch>
```

#### 2.坐标变换

如果启动时加载了机器人模型，且模型中设置的坐标系名称与机器人实体中设置的坐标系一致，那么可以不再添加坐标变换，因为机器人模型可以发布坐标变换信息，如果没有启动机器人模型，就需要自定义坐标变换实现了，继续新建launch文件。

内容如下:

```xml
<!-- 机器人启动文件：
        当不包含机器人模型时，需要发布坐标变换
 -->

<launch>
    <include file="$(find mycar_start)/launch/start.launch" />    
    <node name="camera2basefootprint" pkg="tf2_ros" type="static_transform_publisher" args="0.08 0 0.1 0 0 0 /base_footprint /camera_link"/>
    <node name="rplidar2basefootprint" pkg="tf2_ros" type="static_transform_publisher" args="0 0 0.1 0 0 0 /base_footprint /laser"/>
</launch>
```

#### 3.测试

最后，就可以启动PC端与树莓派端相关节点并运行查看结果了:

##### 1.树莓派

直接执行上一步的机器人启动launch文件:

```
roslaunch 自定义包 自定义launch文件
```

##### 2.PC端

启动键盘控制节点:

```
rosrun teleop_twist_keyboard teleop_twist_keyboard.py
```

还需要启动rviz:

```
rviz
```

##### 3.结果显示

在rviz中添加laserscan、image等插件，并通过键盘控制机器人运动，查看rviz中的显示结果:

![img](http://www.autolabor.com.cn/book/ROSTutorials/assets/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%A1%AC%E4%BB%B6%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95.PNG)

[
  ](http://www.autolabor.com.cn/book/ROSTutorials/di-8-zhang-gou-jian-lun-shi-cha-fen-ji-qi-ren/89-ben-zhang-xiao-jie.html)

## 8.7 本章小结

本章从0到1的介绍了如何构建低成本、实验性的机器人平台，主要内容是围绕机器人的组成展开的，也即:执行机构、驱动系统、控制系统、传感系统。

我们也主要围绕这几个方面做一下总结:

**执行机构**

执行机构是纯硬件实现，在我们的机器人平台中，主要是机器人的行走部分，行走部分的核心是电机，电机的一些参数以及不同参数之间的换算是需要了解的。

**驱动系统**

驱动系统我们采用的是简单、易上手的Arduino再结合电机驱动模块，主要介绍了 arduino 的基本使用，并通ros_arduino_bridge搭建了机器人底盘，该底盘可以解析速度消息并转换成控制电机运动的PWM信号，还可以发布里程计消息。

**控制系统**

控制系统是通过PC与树莓派多处理器结合的方式来实现的，PC扮演了监控的角色，而树莓派则担当数据下发与采集的角色，具体介绍了PC与树莓派的分布式框架实现、如何通过SSH实现远程登陆以及ros_arduino_bridge在树莓派上部署。

**传感系统**

传感系统则介绍了机器人中一些常用的传感器的相关内容，其中，在驱动系统实现时，就涉及到了内部传感器编码器的工作原理以及使用，最后机器人系统集成时又介绍了相机与激光雷达的概念以及应用。

本章内容最终结果就是搭建了一个机器人平台，并且安装、调试了各个组成模块，下一章开始我们将基于这个机器人平台整合各个模块并实现导航功能。

